head	1.14;
access;
symbols;
locks; strict;
comment	@# @;


1.14
date	96.09.06.06.55.28;	author leo;	state Exp;
branches;
next	1.13;

1.13
date	96.06.21.06.09.40;	author leo;	state Exp;
branches;
next	1.12;

1.12
date	96.06.10.16.02.52;	author leo;	state Exp;
branches;
next	1.11;

1.11
date	96.03.28.23.41.45;	author msmeissn;	state Exp;
branches;
next	1.10;

1.10
date	96.03.27.13.48.10;	author leo;	state Exp;
branches;
next	1.9;

1.9
date	96.03.25.11.21.48;	author msmeissn;	state Exp;
branches;
next	1.8;

1.8
date	96.03.22.22.20.59;	author msmeissn;	state Exp;
branches;
next	1.7;

1.7
date	96.03.22.12.14.36;	author msmeissn;	state Exp;
branches;
next	1.6;

1.6
date	96.03.21.15.56.48;	author msmeissn;	state Exp;
branches;
next	1.5;

1.5
date	96.03.21.13.52.45;	author msmeissn;	state Exp;
branches;
next	1.4;

1.4
date	96.03.19.21.41.12;	author msmeissn;	state Exp;
branches;
next	1.3;

1.3
date	96.03.19.20.49.51;	author msmeissn;	state Exp;
branches;
next	1.2;

1.2
date	96.03.19.20.49.39;	author msmeissn;	state Exp;
branches;
next	1.1;

1.1
date	96.03.17.18.07.18;	author leo;	state Exp;
branches;
next	;


desc
@dumb terminal emulation
@


1.14
log
@added getTerminalType() to retrieve terminal id
@
text
@/*
 * Terminal -- Terminal emulation (abstract class)
 * --
 * $Id: Terminal.java,v 1.13 1996/06/21 06:09:40 leo Exp leo $
 * $timestamp: Fri Sep  6 08:54:59 1996 by Matthias L. Jugel :$
 *
 * This file is part of "The Java Telnet Applet".
 *
 * This is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * "The Java Telnet Applet" is distributed in the hope that it will be 
 * useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

package display;

import java.awt.Panel;
import java.awt.Dimension;
import socket.StatusPeer;

/**
 * Terminal is an abstract emulation class.
 * It contains a character display.
 *
 * @@version $Id: Terminal.java,v 1.13 1996/06/21 06:09:40 leo Exp leo $
 * @@author  Matthias L. Jugel, Marcus Meiﬂner
 */
public abstract class Terminal extends Panel
{
	protected StatusPeer peer;

	public void setPeer(StatusPeer p) { peer = p; }
	/**
	 * Get the specific parameter info for the emulation.
	 * @@see java.applet.Applet
	 */
	public abstract String[][] getParameterInfo();
  
	/**
	 * Initianlize Terminal.
	 * @@param parent the object where to get parameters from
	 */
	public abstract void InitializeTerminal(Object parent);

	/**
	 * Put a character on the screen. The method has to see if it is
	 * a special character that needs to be handles special.
	 * @@param c the character
	 * @@see #putString
	 */
	public abstract void putChar(char c);

	/**
	 * Put a character on the screen. The method has to parse the string
	 * may handle special characters.
	 * @@param s the string
	 * @@see #putString
	 */
	public abstract void putString(String s);

	/**
	 * Return the current size of the terminal in characters.
	 */
  	public abstract Dimension getSize();
  
  	/**
   	 * Return actual terminal type identifier.
   	 */
  	public abstract String getTerminalType();
}
@


1.13
log
@*** empty log message ***
@
text
@d4 2
a5 2
 * $Id: Terminal.java,v 1.12 1996/06/10 16:02:52 leo Exp leo $
 * $timestamp: Wed Mar 27 14:22:39 1996 by Matthias L. Jugel :$
d35 1
a35 1
 * @@version $Id: Terminal.java,v 1.12 1996/06/10 16:02:52 leo Exp leo $
d76 4
@


1.12
log
@final revision.
@
text
@d4 1
a4 1
 * $Id: Terminal.java,v 1.11 1996/03/28 23:41:45 msmeissn Exp leo $
d20 1
a20 1
 * along with GNU Emacs; see the file COPYING.  If not, write to the
d35 1
a35 1
 * @@version $Id: Terminal.java,v 1.11 1996/03/28 23:41:45 msmeissn Exp leo $
@


1.11
log
@statuspeer functionality
/.
@
text
@d4 1
a4 1
 * $Id: Terminal.java,v 1.10 1996/03/27 13:48:10 leo Exp msmeissn $
d6 17
d34 3
a36 2
 * @@author	Matthias L. Jugel
 * @@version	$Id: Terminal.java,v 1.10 1996/03/27 13:48:10 leo Exp msmeissn $
@


1.10
log
@Abstract class is now very clean.
@
text
@d4 1
a4 1
 * $Id: Terminal.java,v 1.9 1996/03/25 11:21:48 msmeissn Exp leo $
d12 1
d18 1
a18 1
 * @@version	$Id: Terminal.java,v 1.9 1996/03/25 11:21:48 msmeissn Exp leo $
d22 3
@


1.9
log
@*** empty log message ***
@
text
@d4 2
a5 2
 * $Id: Terminal.java,v 1.8 1996/03/22 22:20:59 msmeissn Exp msmeissn $
 * $timestamp: Fri Mar 22 12:03:10 1996 by Matthias L. Jugel :$
a11 1
import display.CharDisplay;
d17 1
a17 1
 * @@version	$Id: Terminal.java,v 1.8 1996/03/22 22:20:59 msmeissn Exp msmeissn $
d19 1
a19 1
public class Terminal extends Panel
d22 2
a23 1
	 * The character display.
d25 2
a26 23
	protected CharDisplay display;

	/**
	 * Initianlize Terminal with a standard size and font.
	 */
	public void InitializeTerminal() {
		display = new CharDisplay();
	}

	/**
	 * Initianlize Terminal with a given size and standard font.
	 */
	public void InitializeTerminal(int width, int height) {
		display = new CharDisplay(width, height);
	}

	/**
	 * Initianlize Terminal with given font and standard size.
	 */
	public void InitializeTerminal(String font, int fsize) {
		display = new CharDisplay(font, fsize);
	}

d28 2
a29 1
	 * Initianlize Terminal with a given size and font.
d31 1
a31 4
	public void InitializeTerminal(int width, int height, 
                                       String font, int fsize) {
		display = new CharDisplay(width, height, font, fsize);
	}
d39 1
a39 1
	public void putChar(char c) { }
d47 1
a47 1
	public void putString(String s) { }
d52 2
a53 3
	public Dimension getSize() {
		return new Dimension(display.getColumns(), display.getRows());
	}
@


1.8
log
@*** empty log message ***
@
text
@d4 1
a4 1
 * $Id$
d18 1
a18 1
 * @@version	$Id$
@


1.7
log
@my latest release
@
text
@d2 1
a2 1
 * Terminal -- a Terminal emulation
d4 2
a5 2
 * $Id: Terminal.java,v 1.6 1996/03/21 15:56:48 msmeissn Exp msmeissn $
 * $timestamp: Tue Mar 19 21:17:39 1996 by leo :$
d10 2
d15 2
a16 2
 * Terminal is an emulation class currently supporting
 * *DUMB*
d18 1
d20 1
a20 1
public class Terminal extends CharDisplay
d22 4
a25 3
	/* X - COLUMNS, Y - ROWS */
	int	R,C;
	int	attributes = 0;
d27 6
a32 7
	private	static	int	lastwaslf = 0;
	private static	int i;
	private final static char ESC = 27;
	private final static int TSTATE_DATA	= 0;
	private final static int TSTATE_ESC	= 1; /* ESC */
	private final static int TSTATE_DCE	= 2; /* ESC [ */
	private final static int TSTATE_DCEQ	= 3; /* ESC [? */
a33 5
	private int term_state = TSTATE_DATA;
	private int[]	DCEvars = new int [4]; /* enough ? */
	private	int	DCEvar;
	private int	haveQuest = 0;
  
d35 1
a35 2
	 * Put String at current cursor position. Moves cursor
	 * according to the String. Does NOT wrap.
d37 3
a39 2
	public void putString(String s) {
		int	i,len=s.length();
d41 5
a45 5
		markLine(R,1);
		for (i=0;i<len;i++)
			putChar(s.charAt(i),false);
		putCursor(C, R);
		redraw();
d48 6
a53 3
	public void putChar(char c) {
		putChar(c,true);
		redraw();
a54 181
	public void putChar(char c,boolean doshowcursor) {
		markLine(R,1);
		switch (term_state) {
		case TSTATE_DATA:
			switch (c) {
			case ESC:
				term_state = TSTATE_ESC;
				lastwaslf=0;
				System.out.println("->TS_ESC");
				break;
			case '\b':
				C--;
				if (C<0) 
					C=0;
				putChar(C,R,' ',attributes);
				break;
			case '\r':
			case '\n':
				if (lastwaslf!=0 && lastwaslf!=c) 
					break;
				lastwaslf=c;
				if (R < getRows()-1)
					R++;
				else
					insertLine(R);
				C = 0;
				break;
			default:
				lastwaslf=0;
				if(C >= getColumns()) {
					if(R < getRows() - 1) 
						R++;
					else 	
						insertLine(R);
					C = 0;
				} else {
					putChar(C, R, c, attributes);
					C++;
				}
				break;
			}
			break;
		case TSTATE_ESC:
			switch (c) {
			case '[':
				System.out.println("->TS_DCE");
				term_state = TSTATE_DCE;
				DCEvar		= 0;
				DCEvars[0]	= 0;
				haveQuest	= 0;
				break;
			default:
				System.out.println("ESC follows: "+c);
				System.out.println("->TS_DATA");
				term_state = TSTATE_DATA;
				break;
			}
			break;
		case TSTATE_DCE:
			switch (c) {
			case '?':
				haveQuest = 1;
				break;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				System.out.println("DCEvars[DCEvar] = "+
					DCEvars[DCEvar]+", c = "+(int)c
				);
				DCEvars[DCEvar]=DCEvars[DCEvar]*10+((int)c)-48;
				System.out.println("-> DCEvars[DCEvar] = "+
					DCEvars[DCEvar]
				);
				break;
			case 'l':
				if (haveQuest==1) {
					System.out.println(" ESC [ ? "+DCEvars[0]+" l");
					term_state = TSTATE_DATA;
					break;
				} else {
			/* mode reset ... */
				}
				break;
			case ';':
				DCEvar++;
				DCEvars[DCEvar] = 0;
				break;
			case 'B':	/* cursor down n (1) times */
				if (DCEvars[0]>0)
					R+=DCEvars[0];
				else
					R++;
				System.out.println("->TS_DATA");
				term_state = TSTATE_DATA;
				break;
			case 'H':	/* move cursor */
				System.out.println("->H("+DCEvars[0]+";"+DCEvars[1]);
				/* gets 2 arguments */
				C = DCEvars[0];
				R = DCEvars[1];
				term_state = TSTATE_DATA;
				break;
			case 'K':
				/* erase in line */
				switch (DCEvars[0]) {
				case 0:
					deleteArea(C+1,R,getColumns()-1,R);
					break;
				case 1:
					deleteArea(0,R,C-1,R);
					break;
				case 2:
					deleteArea(0,R,getColumns()-1,R);
					break;
				}
				System.out.println("ESC Ps K");
				term_state = TSTATE_DATA;
				break;
			case 'J':
				int	rows,columns;
				/* clear display below current line */
				rows	= getRows();
				columns	= getColumns();
				System.out.println("->J");
				if (DCEvar<1)
					DCEvars[0]=0;
				switch (DCEvars[0]) {
				case 0:
					deleteArea(0,R+1,columns-1,rows-1);
					break;
				case 1:
					deleteArea(0,0,columns-1,R-1);
					break;
				case 2:
					deleteArea(0,0,columns-1,rows-1);
					break;
				}
				System.out.println("->TS_DATA");
				term_state = TSTATE_DATA;
				break;
			case 'm':	/* attributes as color, bold , blink,*/
				attributes = 0;
				for (i=0;i<=DCEvar;i++) {
					switch (DCEvars[i]) {
					case 4:
						attributes |= UNDERLINE;
						break;
					case 1:
						System.out.println("->BOLD");
						attributes |= BOLD;
						break;
					case 7:
						attributes |= INVERT;
						break;
					case 30:
					case 31:
					case 32:
					case 33:
					case 34:
					case 35:
					case 36:
					case 37:
						attributes |= (DCEvars[i]-30)<<3;
						break;
					case 40:
					case 41:
					case 42:
					case 43:
					case 44:
					case 45:
					case 46:
					case 47:
						attributes |= (DCEvars[i]-40)<<6;
						break;
d56 21
a76 27
					default:
						System.out.println(
							"DCEvars[i]"+
							DCEvars[i]
						);
						
						break;
					}
				}
				System.out.println("->TS_DATA");
				term_state = TSTATE_DATA;
				break;
			default:
				System.out.println("ESC [ follows: "+c);
				System.out.println("->TS_DATA");
				term_state = TSTATE_DATA;
				break;
			}
			break;
		default:
			term_state = TSTATE_DATA;
			break;
		}
		if (doshowcursor) {
			putCursor(C, R);
		}
		markLine(R,1);
@


1.6
log
@*** empty log message ***
@
text
@d4 1
a4 1
 * $Id: Terminal.java,v 1.5 1996/03/21 13:52:45 msmeissn Exp msmeissn $
d29 1
d34 1
d103 1
d106 1
d114 3
d135 9
d148 8
a158 2
				if (DCEvar!=1)
					break;
a160 1
				System.out.println("->TS_DATA");
d163 16
d180 1
d182 2
a183 2
				int	len;

d185 12
a196 3
				len=24;
				for (i=0;i<len;i++) {
					deleteLine(0);
d249 1
@


1.5
log
@..
@
text
@d4 1
a4 1
 * $Id: Terminal.java,v 1.4 1996/03/19 21:41:12 msmeissn Exp msmeissn $
d23 2
a24 1
	private static int i;
d41 1
d45 1
d50 1
d52 2
a53 4

	public void putChar(char c, boolean dodisp) {
		boolean	isprintable;

d59 1
d62 7
d70 3
a72 1
				putCursor(C, R);
d80 1
a81 1
					putCursor(C, R);
d88 1
a88 1
					putChar(C, R, c, attributes, false);
a146 1

d168 21
d211 1
a211 1
		if (dodisp) {
d214 1
@


1.4
log
@*** empty log message ***
@
text
@d4 1
a4 1
 * $Id: Terminal.java,v 1.3 1996/03/19 20:49:51 msmeissn Exp msmeissn $
d19 13
a31 1
  int x,y;
d33 6
a38 20
  /**
   * Put String at current cursor position. Moves cursor
   * according to the String. Does NOT wrap.
   */
  public void putString(String s)
  {
    int eol;
    
    while((eol = s.indexOf('\n')) > -1 /* || (eol = s.indexOf('\r')) > -1 */)
    {
      putString(x, y, s.substring(0, eol));
      if(y < getRows() - 1) y++;
      else insertLine(y);
      x = 0;
      s = s.substring(eol+1);
    }
    putString(x, y, s);
    x += s.length();
    putCursor(x, y);
  }
d40 143
a182 13
  public void putChar(char c)
  {
    
    if(x >= getColumns()) 
    {
      c = 0;
      if(y < getRows() - 1) y++;
      else insertLine(y);
    }
    putChar(x, y, c);
    x++;
    putCursor(x, y);
  }
@


1.3
log
@*** empty log message ***
@
text
@d4 1
a4 1
 * $Id: Terminal.java,v 1.2 1996/03/19 20:45:55 leo Exp $
d44 1
@


1.2
log
@*** empty log message ***
@
text
@d4 2
a5 2
 * $Id: Terminal.java,v 1.1 1996/03/17 18:07:18 leo Exp msmeissn $
 * $timestamp::$
d39 1
a39 1
    putChar(x, y, ' ', CharDisplay.INVERT);
d52 1
a52 1
    putChar(x, y, ' ', CharDisplay.INVERT);
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
 * $Id$
@
