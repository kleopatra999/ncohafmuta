head	1.15;
access;
symbols;
locks; strict;
comment	@# @;


1.15
date	96.07.19.12.30.53;	author leo;	state Exp;
branches;
next	1.14;

1.14
date	96.07.02.17.26.49;	author leo;	state Exp;
branches;
next	1.13;

1.13
date	96.06.21.07.37.32;	author leo;	state Exp;
branches;
next	1.12;

1.12
date	96.06.21.06.10.52;	author leo;	state Exp;
branches;
next	1.11;

1.11
date	96.03.28.23.42.01;	author msmeissn;	state Exp;
branches;
next	1.10;

1.10
date	96.03.27.14.29.56;	author msmeissn;	state Exp;
branches;
next	1.9;

1.9
date	96.03.22.12.51.37;	author msmeissn;	state Exp;
branches;
next	1.8;

1.8
date	96.03.22.12.42.51;	author msmeissn;	state Exp;
branches;
next	1.7;

1.7
date	96.03.21.13.54.18;	author msmeissn;	state Exp;
branches;
next	1.6;

1.6
date	96.03.21.13.52.25;	author msmeissn;	state Exp;
branches;
next	1.5;

1.5
date	96.03.19.19.59.40;	author msmeissn;	state Exp;
branches;
next	1.4;

1.4
date	96.03.19.18.40.00;	author msmeissn;	state Exp;
branches;
next	1.3;

1.3
date	96.03.19.15.00.40;	author leo;	state Exp;
branches;
next	1.2;

1.2
date	96.03.19.15.00.18;	author leo;	state Exp;
branches;
next	1.1;

1.1
date	96.03.17.18.07.18;	author leo;	state Exp;
branches;
next	;


desc
@simple telnet IO implementation
@


1.15
log
@fixed some typos.
@
text
@/**
 * socket.TelnetIO - a telnet implementation
 * --
 * $Id: TelnetIO.java,v 1.14 1996/07/02 17:26:49 leo Exp leo $
 * $timestamp: Fri Jul 19 13:25:23 1996 by Matthias L. Jugel :$
 *
 * This file is part of "The Java Telnet Applet".
 *
 * This is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * "The Java Telnet Applet" is distributed in the hope that it will be 
 * useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

package socket;

import java.net.Socket;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.IOException;
import java.awt.Dimension;
import java.util.Vector;

import socket.StatusPeer;

/**
 * Implements simple telnet io
 *
 * @@version $Id: TelnetIO.java,v 1.14 1996/07/02 17:26:49 leo Exp leo $
 * @@author  Matthias L. Jugel, Marcus Meiﬂner
 */
public class TelnetIO implements StatusPeer
{
	/**
	 * Debug level. This results in additional diagnostic messages on the
	 * java console.
	 */
	private int debug = 0;

	/**
	 * State variable for telnetnegotiation reader
	 */
	private byte neg_state = 0;

	/**
	 * constants for the negotiation state
	 */
	private final static byte STATE_DATA	= 0;
	private final static byte STATE_IAC	= 1;
	private final static byte STATE_IACSB	= 2;
	private final static byte STATE_IACWILL	= 3;
	private final static byte STATE_IACDO	= 4;
	private final static byte STATE_IACWONT	= 5;
	private final static byte STATE_IACDONT	= 6;
	private final static byte STATE_IACSBIAC	= 7;
	private final static byte STATE_IACSBDATA	= 8;
	private final static byte STATE_IACSBDATAIAC	= 9;

	/**
	 * What IAC SB <xx> we are handling right now
	 */
	private byte current_sb;

	/**
	 * IAC - init sequence for telnet negotiation.
	 */
	private final static byte IAC  = (byte)255;
	/**
	 * [IAC] End Of Record
	 */
	private final static byte EOR  = (byte)239;
	/**
	 * [IAC] WILL
	 */
	private final static byte WILL  = (byte)251;
	/**
	 * [IAC] WONT
	 */
	private final static byte WONT  = (byte)252;
	/**
	 * [IAC] DO
	 */
	private final static byte DO    = (byte)253;
	/**
	 * [IAC] DONT
	 */
	private final static byte DONT  = (byte)254;
	/**
	 * [IAC] Sub Begin 
	 */
	private final static byte SB  = (byte)250;
	/**
	 * [IAC] Sub End
	 */
	private final static byte SE  = (byte)240;
	/**
	 * Telnet option: echo text
	 */
	private final static byte TELOPT_ECHO  = (byte)1;  /* echo on/off */
	/**
	 * Telnet option: End Of Record
	 */
	private final static byte TELOPT_EOR   = (byte)25;  /* end of record */
	/**
	 * Telnet option: Negotiate About Window Size
	 */
	private final static byte TELOPT_NAWS  = (byte)31;  /* NA-WindowSize*/
	/**
	 * Telnet option: Terminal Type
	 */
	private final static byte TELOPT_TTYPE  = (byte)24;  /* terminal type */

	private final static byte[] IACWILL  = { IAC, WILL };
	private final static byte[] IACWONT  = { IAC, WONT };
	private final static byte[] IACDO    = { IAC, DO	};
	private final static byte[] IACDONT  = { IAC, DONT };
	private final static byte[] IACSB  = { IAC, SB };
	private final static byte[] IACSE  = { IAC, SE };

	/** 
	 * Telnet option qualifier 'IS' 
	 */
	private final static byte TELQUAL_IS = (byte)0;

	/** 
	 * Telnet option qualifier 'SEND' 
	 */
	private final static byte TELQUAL_SEND = (byte)1;

	/**
	 * What IAC DO(NT) request do we have received already ?
	 */
	private byte[] receivedDX = new byte[256];
	/**
	 * What IAC WILL/WONT request do we have received already ?
	 */
	private byte[] receivedWX = new byte[256];
	/**
	 * What IAC DO/DONT request do we have sent already ?
	 */
	private byte[] sentDX = new byte[256];
	/**
	 * What IAC WILL/WONT request do we have sent already ?
	 */
	private byte[] sentWX = new byte[256];

	private Socket socket;
	private BufferedInputStream is;
	private BufferedOutputStream os;

	private StatusPeer peer = this;		/* peer, notified on status */

	/**
	 * Connect to the remote host at the specified port.
	 * @@param address the symbolic host address
	 * @@param port the numeric port
	 * @@see #disconnect
	 */
	public void connect(String address, int port) throws IOException {
		if(debug > 0) System.out.println("Telnet.connect("+address+","+port+")");
		socket = new Socket(address, port);
		is = new BufferedInputStream(socket.getInputStream());
		os = new BufferedOutputStream(socket.getOutputStream());
	}

	/**
	 * Disconnect from remote host.
	 * @@see #connect
	 */
	public void disconnect() throws IOException {
	  if(debug > 0) System.out.println("Telnet.disconnect()");
	  if(socket !=null) socket.close();
	}
  
	/**
	 * Connect to the remote host at the default telnet port (23).
	 * @@param address the symbolic host address
	 */
	public void connect(String address) throws IOException {
		connect(address, 23);
	}

	/**
	 * Set the object to be notified about current status.
	 * @@param obj object to be notified.
	 */
	public void setPeer(StatusPeer obj) { peer = obj; }

	/**
	 * Read data from the remote host. Blocks until data is available. 
	 * Returns an array of bytes.
	 * @@see #send
	 */
	public byte[] receive() throws IOException {
		int count = is.available();
		byte buf[] = new byte[count];
		count = is.read(buf);
		if(count < 0) throw new IOException("Connection closed.");
		if(debug > 1) System.out.println("TelnetIO.receive(): read bytes: "+count);
		buf = negotiate(buf, count);
		return buf;
	}

	/**
	 * Send data to the remote host.
	 * @@param buf array of bytes to send
	 * @@see #receive
	 */
	public void send(byte[] buf) throws IOException {
		if(debug > 1) System.out.println("TelnetIO.send("+buf+")");
		os.write(buf);
		os.flush();
	}

	public void send(byte b) throws IOException {
		if(debug > 1) System.out.println("TelnetIO.send("+b+")");
		os.write(b);
		os.flush();
	}

	/**
	 * Handle an incoming IAC SB <type> <bytes> IAC SE
	 * @@param type type of SB
	 * @@param sbata byte array as <bytes>
	 * @@param sbcount nr of bytes. may be 0 too.
	 */
	private void handle_sb(byte type, byte[] sbdata, int sbcount) 
		throws IOException 
	{
		if(debug > 1) 
			System.out.println("TelnetIO.handle_sb("+type+")");
		switch (type) {
		case TELOPT_TTYPE:
			if (sbcount>0 && sbdata[0]==TELQUAL_SEND) {
				String ttype;
				send(IACSB);send(TELOPT_TTYPE);send(TELQUAL_IS);
				/* FIXME: need more logic here if we use 
				 * more than one terminal type
				 */
				Vector vec = new Vector(2);
				vec.addElement("TTYPE");
				ttype = (String)peer.notifyStatus(vec);
				if(ttype == null) ttype = "dumb";
				byte[] bttype = new byte[ttype.length()];

				ttype.getBytes(0,ttype.length(), bttype, 0);
				send(bttype);
				send(IACSE);
			}

		}
	}

	/**
	 * Notify about current telnet status. This method is called top-down.
	 * @@param status contains status information
	 */
	public Object notifyStatus(Vector status) {
		if(debug > 0) 
			System.out.println("Telnet.notifyStatus("+status+")");
		return null;
	}

	/* wo faengt buf an bei buf[0] oder bei buf[1] */
	private byte[] negotiate(byte buf[], int count) throws IOException {
		if(debug > 1) 
			System.out.println("TelnetIO.negotiate("+buf+","+count+")");
		byte nbuf[] = new byte[count];
		byte sbbuf[] = new byte[count];
		byte sendbuf[] = new byte[3];
		byte b,reply;
		int	sbcount = 0;
		int boffset = 0, noffset = 0;
		Vector	vec = new Vector(2);

		while(boffset < count) {
			b=buf[boffset++];
			switch (neg_state) {
			case STATE_DATA:
				if (b==IAC) {
					neg_state = STATE_IAC;
				} else {
					nbuf[noffset++]=b;
				}
				break;
			case STATE_IAC:
				switch (b) {
				case IAC:
					if(debug > 2) 
						System.out.println("IAC ");
					neg_state = STATE_DATA;
					nbuf[noffset++]=IAC;
					break;
				case WILL:
					if(debug > 2)
						System.out.println("WILL ");
					neg_state = STATE_IACWILL;
					break;
				case WONT:
					if(debug > 2)
						System.out.println("WONT ");
					neg_state = STATE_IACWONT;
					break;
				case DONT:
					if(debug > 2)
						System.out.println("DONT ");
					neg_state = STATE_IACDONT;
					break;
				case DO:
					if(debug > 2)
						System.out.println("DO ");
					neg_state = STATE_IACDO;
					break;
				case EOR:
					if(debug > 2)
						System.out.println("EOR ");
					neg_state = STATE_DATA;
					break;
				case SB:
					if(debug > 2)
						System.out.println("SB ");
					neg_state = STATE_IACSB;
					sbcount = 0;
					break;
				default:
					if(debug > 2)
						System.out.println(
							"<UNKNOWN "+b+" > "
						);
					neg_state = STATE_DATA;
					break;
				}
				break;
			case STATE_IACWILL:
				switch(b) {
				case TELOPT_ECHO:
					if(debug > 2) 
						System.out.println("ECHO");
					reply = DO;
					vec = new Vector(2);
					vec.addElement("NOLOCALECHO");
					peer.notifyStatus(vec);
					break;
				case TELOPT_EOR:
					if(debug > 2) 
						System.out.println("EOR");
					reply = DO;
					break;
				default:
					if(debug > 2)
						System.out.println(
							"<UNKNOWN,"+b+">"
						);
					reply = DONT;
					break;
				}
				if(debug > 1)
				  System.out.println("<"+b+", WILL ="+WILL+">");
				if (	reply != sentDX[b+128] ||
					WILL != receivedWX[b+128]
				) {
					sendbuf[0]=IAC;
					sendbuf[1]=reply;
					sendbuf[2]=b;
					send(sendbuf);
					sentDX[b+128] = reply;
					receivedWX[b+128] = WILL;
				}
				neg_state = STATE_DATA;
				break;
			case STATE_IACWONT:
				switch(b) {
				case TELOPT_ECHO:
					if(debug > 2) 
						System.out.println("ECHO");

					vec = new Vector(2);
					vec.addElement("LOCALECHO");
					peer.notifyStatus(vec);
					reply = DONT;
					break;
				case TELOPT_EOR:
					if(debug > 2) 
						System.out.println("EOR");
					reply = DONT;
					break;
				default:
					if(debug > 2) 
						System.out.println(
							"<UNKNOWN,"+b+">"
						);
					reply = DONT;
					break;
				}
				if (	reply != sentDX[b+128] ||
					WONT != receivedWX[b+128]
				) {
					sendbuf[0]=IAC;
					sendbuf[1]=reply;
					sendbuf[2]=b;
					send(sendbuf);
					sentDX[b+128] = reply;
					receivedWX[b+128] = WILL;
				}
				neg_state = STATE_DATA;
				break;
			case STATE_IACDO:
				switch (b) {
				case TELOPT_ECHO:
					if(debug > 2) 
						System.out.println("ECHO");
					reply = WILL;
					vec = new Vector(2);
					vec.addElement("LOCALECHO");
					peer.notifyStatus(vec);
					break;
				case TELOPT_TTYPE:
					if(debug > 2) 
						System.out.println("TTYPE");
					reply = WILL;
					break;
				case TELOPT_NAWS:
					if(debug > 2) 
						System.out.println("NAWS");
					vec = new Vector(2);
					vec.addElement("NAWS");
					Dimension size = (Dimension)
						peer.notifyStatus(vec);
					receivedDX[b] = DO;
					if(size == null)
					{
						/* this shouldn't happen */
						send(IAC);
						send(WONT);
						send(TELOPT_NAWS);
						reply = WONT;
						sentWX[b] = WONT;
						break;
					}
					reply = WILL;
					sentWX[b] = WILL;
					sendbuf[0]=IAC;
					sendbuf[1]=WILL;
					sendbuf[2]=TELOPT_NAWS;
					send(sendbuf);
					send(IAC);send(SB);send(TELOPT_NAWS);
					send((byte) (size.width >> 8));
					send((byte) (size.width & 0xff));
					send((byte) (size.height >> 8));
					send((byte) (size.height & 0xff));
					send(IAC);send(SE);
					break;
				default:
					if(debug > 2) 
						System.out.println(
							"<UNKNOWN,"+b+">"
						);
					reply = WONT;
					break;
				}
				if (	reply != sentWX[128+b] ||
					DO != receivedDX[128+b]
				) {
					sendbuf[0]=IAC;
					sendbuf[1]=reply;
					sendbuf[2]=b;
					send(sendbuf);
					sentWX[b+128] = reply;
					receivedDX[b+128] = DO;
				}
				neg_state = STATE_DATA;
				break;
			case STATE_IACDONT:
				switch (b) {
				case TELOPT_ECHO:
					if(debug > 2) 
						System.out.println("ECHO");
					reply	= WONT;
					vec = new Vector(2);
					vec.addElement("NOLOCALECHO");
					peer.notifyStatus(vec);
					break;
				case TELOPT_NAWS:
					if(debug > 2) 
						System.out.println("NAWS");
					reply	= WONT;
					break;
				default:
					if(debug > 2) 
						System.out.println(
							"<UNKNOWN,"+b+">"
						);
					reply	= WONT;
					break;
				}
				if (	reply	!= sentWX[b+128] ||
					DONT	!= receivedDX[b+128]
				) {
					send(IAC);send(reply);send(b);
					sentWX[b+128]		= reply;
					receivedDX[b+128]	= DONT;
				}
				neg_state = STATE_DATA;
				break;
			case STATE_IACSBIAC:
				if(debug > 2) System.out.println(""+b+" ");
				if (b == IAC) {
					sbcount		= 0;
					current_sb	= b;
					neg_state	= STATE_IACSBDATA;
				} else {
					System.out.println("(bad) "+b+" ");
					neg_state	= STATE_DATA;
				}
				break;
			case STATE_IACSB:
				if(debug > 2) System.out.println(""+b+" ");
				switch (b) {
				case IAC:
					neg_state = STATE_IACSBIAC;
					break;
				default:
					current_sb	= b;
					sbcount		= 0;
					neg_state	= STATE_IACSBDATA;
					break;
				}
				break;
			case STATE_IACSBDATA:
				if (debug > 2) System.out.println(""+b+" ");
				switch (b) {
				case IAC:
					neg_state = STATE_IACSBDATAIAC;
					break;
				default:
					sbbuf[sbcount++] = b;
					break;
				}
				break;
			case STATE_IACSBDATAIAC:
				if (debug > 2) System.out.println(""+b+" ");
				switch (b) {
				case IAC:
					neg_state = STATE_IACSBDATA;
					sbbuf[sbcount++] = IAC;
					break;
				case SE:
					handle_sb(current_sb,sbbuf,sbcount);
					current_sb	= 0;
					neg_state	= STATE_DATA;
					break;
				case SB:
					handle_sb(current_sb,sbbuf,sbcount);
					neg_state	= STATE_IACSB;
					break;
				default:
					neg_state	= STATE_DATA;
					break;
				}
				break;
			default:
				if (debug > 2) 
					System.out.println(
						"This should not happen: "+
						neg_state+" "
					);
				neg_state = STATE_DATA;
				break;
			}
		}
		buf	= new byte[noffset];
		System.arraycopy(nbuf, 0, buf, 0, noffset);
		return buf;
	}
}
@


1.14
log
@removed some debugging input
@
text
@d2 1
a2 1
 * socket.Telnet - a telnet implementation
d4 2
a5 2
 * $Id: TelnetIO.java,v 1.13 1996/06/21 07:37:32 leo Exp leo $
 * $timestamp: Tue Jul  2 19:21:27 1996 by Matthias L. Jugel :$
d39 1
a39 1
 * @@version $Id: TelnetIO.java,v 1.13 1996/06/21 07:37:32 leo Exp leo $
d165 1
a165 1
	 * @@param addres the symbolic host address
d177 1
a177 1
	 * Disonnect from remote host.
d202 1
a202 1
	 * @@send #send
@


1.13
log
@fixed bug in terminal type negotiation
@
text
@d4 2
a5 2
 * $Id: TelnetIO.java,v 1.12 1996/06/21 06:10:52 leo Exp leo $
 * $timestamp: Fri Mar 22 11:14:08 1996 by Matthias L. Jugel :$
d39 1
a39 1
 * @@version $Id: TelnetIO.java,v 1.12 1996/06/21 06:10:52 leo Exp leo $
d367 2
a368 1
				System.out.println("<"+b+", WILL ="+WILL+">");
@


1.12
log
@*** empty log message ***
@
text
@d4 1
a4 1
 * $Id: TelnetIO.java,v 1.11 1996/03/28 23:42:01 msmeissn Exp leo $
d39 1
a39 1
 * @@version $Id$
d253 1
@


1.11
log
@wech halt
@
text
@d4 1
a4 1
 * $Id: TelnetIO.java,v 1.10 1996/03/27 14:29:56 msmeissn Exp msmeissn $
d6 17
d38 3
@


1.10
log
@*** empty log message ***
@
text
@d4 1
a4 1
 * $Id: TelnetIO.java,v 1.9 1996/03/22 12:51:37 msmeissn Exp msmeissn $
d15 1
d230 3
a232 1
				ttype = (String)peer.notifyStatus("TTYPE");
d247 1
a247 1
	public Object notifyStatus(Object status) {
d263 1
d329 3
a331 1
					peer.notifyStatus("NOLOCALECHO");
d364 4
a367 1
					peer.notifyStatus("LOCALECHO");
d401 3
a403 1
					peer.notifyStatus("LOCALECHO");
d413 2
d416 1
a416 1
						peer.notifyStatus("NAWS");
d467 3
a469 1
					peer.notifyStatus("NOLOCALECHO");
@


1.9
log
@*** empty log message ***
@
text
@d4 1
a4 1
 * $Id: TelnetIO.java,v 1.5 1996/03/19 19:59:40 msmeissn Exp $
d252 2
a253 2
	if(debug > 1) 
		System.out.println("TelnetIO.negotiate("+buf+","+count+")");
d256 1
d344 4
a347 1
					send(IAC);send(reply);send(b);
d377 4
a380 1
					send(IAC);send(reply);send(b);
d417 4
a420 1
					send(IAC);send(WILL);send(TELOPT_NAWS);
d439 4
a442 1
					send(IAC);send(reply);send(b);
@


1.8
log
@*** empty log message ***
@
text
@d4 2
a5 2
 * $Id: TelnetIO.java,v 1.7 1996/03/21 13:54:18 msmeissn Exp msmeissn $
 * $timestamp: Thu Mar 21 14:30:33 1996 by Matthias L. Jugel :$
d141 1
d146 1
d148 1
a148 2
	public void connect(String address, int port) throws IOException
	    {
d156 9
@


1.7
log
@*** empty log message ***
@
text
@d4 1
a4 1
 * $Id: TelnetIO.java,v 1.5 1996/03/19 19:59:40 msmeissn Exp $
d27 1
a27 1
	private int debug = 2;
@


1.6
log
@*** empty log message ***
@
text
@d5 1
a5 1
 * $timestamp: Mon Mar 18 21:31:59 1996 by leo :$
d27 1
a27 1
	private int debug = 0;
d177 1
@


1.5
log
@*** empty log message ***
@
text
@d4 1
a4 1
 * $Id: TelnetIO.java,v 1.4 1996/03/19 18:40:00 msmeissn Exp msmeissn $
d27 1
a27 1
	private int debug = 3;
a108 2
	private final static byte[] TERMVT100 = {(byte)'v',(byte)'t',(byte)'1',(byte)'0',(byte)'0',(byte)'-',(byte)'j',(byte)'a',(byte)'v',(byte)'a'};

d213 1
d218 2
a219 1
				send(TERMVT100);
d221 2
a307 1

d313 1
d343 1
d374 1
d430 1
a518 1
			System.out.println("neg_state = "+neg_state);
@


1.4
log
@public -> private
TTYPE works
misc reformatting
SB works
@
text
@d4 1
a4 1
 * $Id: TelnetIO.java,v 1.3 1996/03/19 15:00:40 leo Exp msmeissn $
d511 1
d514 1
@


1.3
log
@*** empty log message ***
@
text
@d4 1
a4 1
 * $Id: TelnetIO.java,v 1.2 1996/03/19 15:00:18 leo Exp leo $
d27 1
a27 1
	public int debug = 3;
d32 1
a32 1
	public byte neg_state = 0;
d37 10
a46 10
	public final static byte STATE_DATA	= 0;
	public final static byte STATE_IAC	= 1;
	public final static byte STATE_IACSB	= 2;
	public final static byte STATE_IACWILL	= 3;
	public final static byte STATE_IACDO	= 4;
	public final static byte STATE_IACWONT	= 5;
	public final static byte STATE_IACDONT	= 6;
	public final static byte STATE_IACSBIAC	= 7;
	public final static byte STATE_IACSBDATA	= 8;
	public final static byte STATE_IACSBDATAIAC	= 9;
d51 1
a51 1
	public byte current_sb;
d56 1
a56 1
	public final static byte IAC  = (byte)255;
d60 1
a60 1
	public final static byte EOR  = (byte)239;
d64 1
a64 1
	public final static byte WILL  = (byte)251;
d68 1
a68 1
	public final static byte WONT  = (byte)252;
d72 1
a72 1
	public final static byte DO    = (byte)253;
d76 1
a76 1
	public final static byte DONT  = (byte)254;
d80 1
a80 1
	public final static byte SB  = (byte)250;
d84 1
a84 1
	public final static byte SE  = (byte)240;
d88 1
a88 1
	public final static byte TELOPT_ECHO  = (byte)1;  /* echo on/off */
d92 1
a92 1
	public final static byte TELOPT_EOR   = (byte)25;  /* end of record */
d96 5
a100 1
	public final static byte TELOPT_NAWS  = (byte)31;  /* NA-WindowSize*/
d102 6
a107 6
	public final static byte[] IACWILL  = { IAC, WILL };
	public final static byte[] IACWONT  = { IAC, WONT };
	public final static byte[] IACDO    = { IAC, DO	};
	public final static byte[] IACDONT  = { IAC, DONT };
	public final static byte[] IACSB  = { IAC, SB };
	public final static byte[] IACSE  = { IAC, SE };
d109 12
d124 1
a124 1
	public byte[] receivedDX = new byte[256];
d128 1
a128 1
	public byte[] receivedWX = new byte[256];
d132 1
a132 1
	public byte[] sentDX = new byte[256];
d136 1
a136 1
	public byte[] sentWX = new byte[256];
d160 1
a160 2
	public void connect(String address) throws IOException
	    {
d168 1
a168 4
	public void setPeer(StatusPeer obj)
	    {
		peer = obj;
	}
d175 1
a175 2
	public byte[] receive() throws IOException
	    {
d202 26
d232 2
a233 1
		if(debug > 0) System.out.println("Telnet.notifyStatus("+status+")");
a236 2


d239 2
a240 1
		if(debug > 1) System.out.println("TelnetIO.negotiate("+buf+","+count+")");
d260 2
a261 1
					if(debug > 2) System.out.println("IAC ");
d266 2
a267 1
					if(debug > 2) System.out.println("WILL ");
d271 2
a272 1
					if(debug > 2) System.out.println("WONT ");
d276 2
a277 1
					if(debug > 2) System.out.println("DONT ");
d281 2
a282 1
					if(debug > 2) System.out.println("DO ");
d286 2
a287 1
					if(debug > 2) System.out.println("EOR ");
d291 2
a292 1
					if(debug > 2) System.out.println("SB ");
d297 4
a300 1
					if(debug > 2) System.out.println("<UNKNOWN "+b+" > ");
d304 1
d309 2
a310 1
					if(debug > 2) System.out.println("ECHO");
d314 2
a315 1
					if(debug > 2) System.out.println("EOR");
d319 4
a322 1
					if(debug > 2) System.out.println("<UNKNOWN,"+b+">");
d326 1
a326 1
				System.out.println("<"+((char)b)+">");
d339 2
a340 1
					if(debug > 2) System.out.println("ECHO");
d344 2
a345 1
					if(debug > 2) System.out.println("EOR");
d349 4
a352 1
					if(debug > 2) System.out.println("<UNKNOWN,"+b+">");
d368 2
a369 1
					if(debug > 2) System.out.println("ECHO");
d372 5
d378 4
a381 2
					if(debug > 2) System.out.println("NAWS");
					Dimension size = (Dimension)peer.notifyStatus("NAWS");
d386 3
a388 1
						send(IAC);send(WONT);send(TELOPT_NAWS);
d404 4
a407 1
					if(debug > 2) System.out.println("<UNKNOWN,"+b+">");
d423 3
a425 2
					if(debug > 2) System.out.println("ECHO");
					reply = WONT;
d428 3
a430 2
					if(debug > 2) System.out.println("NAWS");
					reply = WONT;
d433 5
a437 2
					if(debug > 2) System.out.println("<UNKNOWN,"+b+">");
					reply = WONT;
d440 2
a441 2
				if (	reply != sentWX[b+128] ||
					DONT != receivedDX[b+128]
d444 2
a445 2
					sentWX[b+128] = reply;
					receivedDX[b+128] = DONT;
d452 3
a454 2
					current_sb = b;
					neg_state = STATE_IACSBDATA;
d457 1
a457 1
					neg_state = STATE_DATA;
d467 3
a469 2
					current_sb = b;
					neg_state = STATE_IACSBDATA;
d472 1
d492 3
a494 1
					neg_state = STATE_DATA;
d496 4
d501 1
a501 1
					neg_state = STATE_DATA;
d506 5
a510 1
				if (debug > 2) System.out.println("This should not happen: "+neg_state+" ");
d514 1
a514 1
		buf = new byte[noffset];
@


1.2
log
@Marcus wars ;)
@
text
@d4 1
a4 1
 * $Id: TelnetIO.java,v 1.1 1996/03/17 18:07:18 leo Exp leo $
@


1.1
log
@Initial revision
@
text
@d4 2
a5 2
 * $Id$
 * $timestamp: Sat Mar 16 22:09:55 1996 by MLJ :$
d16 2
d21 1
a21 1
public class TelnetIO
d23 5
a27 45
  public int debug = 0;
  /**
   * IAC - init sequence for telnet negotiation.
   */
  public final static byte IAC  = (byte)255;
  /**
   * [IAC] End Of Record
   */
  public final static byte EOR  = (byte)239;
  /**
   * [IAC] WILL
   */
  public final static byte WILL  = (byte)251;
  /**
   * [IAC] WONT
   */
  public final static byte WONT  = (byte)252;
  /**
   * [IAC] DO
   */
  public final static byte DO    = (byte)253;
  /**
   * [IAC] DONT
   */
  public final static byte DONT  = (byte)254;
  /**
   * [IAC] Sub Begin 
   */
  public final static byte SB  = (byte)250;
  /**
   * [IAC] Sub End
   */
  public final static byte SE  = (byte)240;
  /**
   * Telnet option: echo text
   */
  public final static byte TELOPT_ECHO  = (byte)1;  /* echo on/off */
  /**
   * Telnet option: End Of Record
   */
  public final static byte TELOPT_EOR   = (byte)25;  /* end of record */
  /**
   * Telnet option: Negotiate About Window Size
   */
  public final static byte TELOPT_NAWS  = (byte)31;  /* NA-WindowSize*/
d29 4
a32 6
  public final static byte[] IACWILL  = { IAC, WILL };
  public final static byte[] IACWONT  = { IAC, WONT };
  public final static byte[] IACDO    = { IAC, DO };
  public final static byte[] IACDONT  = { IAC, DONT };
  public final static byte[] IACSB  = { IAC, SB };
  public final static byte[] IACSE  = { IAC, SE };
d34 13
a46 16
  private Socket socket;
  private BufferedInputStream is;
  private BufferedOutputStream os;
  
  /**
   * Connect to the remote host at the specified port.
   * @@param addres the symbolic host address
   * @@param port the numeric port
   */
  public void connect(String address, int port) throws IOException
  {
    if(debug > 0) System.out.println("Telnet.connect("+address+","+port+")");
    socket = new Socket(address, port);
    is = new BufferedInputStream(socket.getInputStream());
    os = new BufferedOutputStream(socket.getOutputStream());
  }
d48 4
a51 35
  /**
   * Connect to the remote host at the default telnet port (23).
   * @@param address the symbolic host address
   */
  public void connect(String address) throws IOException
  {
    connect(address, 23);
  }
  
  /**
   * Read data from the remote host. Blocks until data is available. 
   * Returns an array of bytes.
   * @@send #send
   */
  public byte[] receive() throws IOException
  {
    int count = is.available();
    byte buf[] = new byte[count];
    count = is.read(buf);
    if(debug > 1) System.out.println("TelnetIO.receive(): read bytes: "+count);
    buf = negotiate(buf, count);
    return buf;
  }
  
  /**
   * Send data to the remote host.
   * @@param buf array of bytes to send
   * @@see #receive
   */
  public void send(byte[] buf) throws IOException
  {
    if(debug > 1) System.out.println("TelnetIO.send("+buf+")");
    os.write(buf);
    os.flush();
  }
d53 44
a96 6
  public void send(byte b) throws IOException
  {
    if(debug > 1) System.out.println("TelnetIO.send("+b+")");
    os.write(b);
    os.flush();
  }
d98 6
a103 9
  /**
   * Notify about current telnet status. This method is called top-down.
   * @@param status contains status information
   */
  public Object notifyStatus(Object status)
  {
    if(debug > 0) System.out.println("Telnet.notifyStatus("+status+")");
    return null;
  }
d105 324
a428 117
  private byte[] negotiate(byte buf[], int count) throws IOException
  {
    if(debug > 1) System.out.println("TelnetIO.negotiate("+buf+","+count+")");
    byte nbuf[] = new byte[count];
    int boffset = 0, noffset = 0;
    while(boffset < count)
    {
      int p = 0;
      while(boffset + p < count && buf[boffset + p] != IAC) p++;
      System.arraycopy(buf, boffset, nbuf, noffset, p);
      boffset += p; noffset += p;
      if(boffset < count && buf[boffset] == IAC)
      {
        byte cmd;
        if(debug > 2) System.out.print("IAC ");
        if(boffset == count) cmd = (byte)is.read();
        else cmd = buf[++boffset];
        switch(cmd)
        {
        case EOR:
          if(debug > 2) System.out.println("EOR ");
          break;
        case WILL:
          if(debug > 2) System.out.print("WILL ");
          if(boffset == count) cmd = (byte)is.read();
          else cmd = buf[++boffset];
          switch(cmd)
          {
          case TELOPT_ECHO:
            if(debug > 2) System.out.println("ECHO");
            send(IACDO); send(TELOPT_ECHO);
            break;
          case TELOPT_EOR:
            if(debug > 2) System.out.println("EOR");
            send(IACDO); send(TELOPT_EOR);
            break;
          default:
            if(debug > 2) System.out.println("<UNKNOWN,"+cmd+">");
            send(IACDONT); send(cmd);
            break;
          }
          break;
        case WONT:
          if(debug > 2) System.out.print("WONT ");
          if(boffset == count) cmd = (byte)is.read();
          else cmd = buf[++boffset];
          switch(cmd)
          {
          case TELOPT_ECHO:
            if(debug > 2) System.out.println("ECHO");
            send(IACDONT); send(TELOPT_ECHO);
            break;
          case TELOPT_EOR:
            if(debug > 2) System.out.println("EOR");
            send(IACDONT); send(TELOPT_EOR);
            break;
          default:
            if(debug > 2) System.out.println("<UNKNOWN,"+cmd+">");
            send(IACDONT); send(cmd);
            break;
          }
          break;
        case DO:
          if(debug > 2) System.out.print("DO ");
          if(boffset == count) cmd = (byte)is.read();
          else cmd = buf[++boffset];
          switch(cmd)
          {
          case TELOPT_ECHO:
            if(debug > 2) System.out.println("ECHO");
            send(IACWILL); send(TELOPT_ECHO);
            break;
          case TELOPT_NAWS:
            if(debug > 2) System.out.println("NAWS");
            Dimension size = (Dimension)this.notifyStatus("NAWS");
            if(size == null)
            {
              send(IACWONT); send(TELOPT_NAWS);
              break;
            }
            send(IACWILL); send(TELOPT_NAWS);
            send(IACSB); send(TELOPT_NAWS);
            send((byte) (size.width >> 8));
            send((byte) (size.width & 0xff));
            send((byte) (size.height >> 8));
            send((byte) (size.height & 0xff));
            send(IACSE); 
            break;
          default:
            if(debug > 2) System.out.println("<UNKNOWN,"+cmd+">");
            send(IACWONT); send(cmd);
            break;
          }
          break;
        case DONT:
          if(debug > 2) System.out.print("DONT ");
          if(boffset == count) cmd = (byte)is.read();
          else cmd = buf[++boffset];
          switch(cmd)
          {
          default:
            if(debug > 2) System.out.println("<UNKNOWN,"+cmd+">");
            send(IACWONT); send(cmd);
            break;
          }
          break;
        default: 
          if(debug > 2) System.out.println("<UNKNOWN,"+cmd+">");
          break;
        }
      }
      boffset++;
    }
    buf = new byte[noffset];
    System.arraycopy(nbuf, 0, buf, 0, noffset);
    return buf;
  }
@
