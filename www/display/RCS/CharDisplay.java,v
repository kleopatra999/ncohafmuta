head	1.36;
branch	1.35.1;
access;
symbols;
locks; strict;
comment	@# @;


1.36
date	96.10.15.12.10.17;	author leo;	state Exp;
branches;
next	1.35;

1.35
date	96.09.05.11.55.40;	author leo;	state Exp;
branches
	1.35.1.1;
next	1.34;

1.34
date	96.08.29.16.02.23;	author leo;	state Exp;
branches;
next	1.33;

1.33
date	96.08.29.15.28.32;	author leo;	state Exp;
branches;
next	1.32;

1.32
date	96.08.02.09.40.26;	author leo;	state Exp;
branches;
next	1.31;

1.31
date	96.07.30.10.30.51;	author leo;	state Exp;
branches;
next	1.30;

1.30
date	96.07.19.12.30.22;	author leo;	state Exp;
branches;
next	1.29;

1.29
date	96.07.03.12.28.00;	author leo;	state Exp;
branches;
next	1.28;

1.28
date	96.07.03.10.11.56;	author leo;	state Exp;
branches;
next	1.27;

1.27
date	96.07.03.08.08.00;	author leo;	state Exp;
branches;
next	1.26;

1.26
date	96.07.02.17.34.10;	author leo;	state Exp;
branches;
next	1.25;

1.25
date	96.06.21.06.09.40;	author leo;	state Exp;
branches;
next	1.24;

1.24
date	96.06.10.16.02.52;	author leo;	state Exp;
branches;
next	1.23;

1.23
date	96.04.18.15.49.58;	author leo;	state Exp;
branches;
next	1.22;

1.22
date	96.04.03.14.19.36;	author leo;	state Exp;
branches;
next	1.21;

1.21
date	96.03.30.23.08.15;	author leo;	state Exp;
branches;
next	1.20;

1.20
date	96.03.30.23.05.25;	author leo;	state Exp;
branches;
next	1.19;

1.19
date	96.03.30.01.30.01;	author leo;	state Exp;
branches;
next	1.18;

1.18
date	96.03.28.22.14.09;	author msmeissn;	state Exp;
branches;
next	1.17;

1.17
date	96.03.28.19.40.45;	author msmeissn;	state Exp;
branches;
next	1.16;

1.16
date	96.03.27.20.02.50;	author msmeissn;	state Exp;
branches;
next	1.15;

1.15
date	96.03.27.16.29.03;	author msmeissn;	state Exp;
branches;
next	1.14;

1.14
date	96.03.27.11.19.30;	author leo;	state Exp;
branches;
next	1.13;

1.13
date	96.03.27.11.02.03;	author leo;	state Exp;
branches;
next	1.12;

1.12
date	96.03.26.16.46.38;	author leo;	state Exp;
branches;
next	1.11;

1.11
date	96.03.26.16.00.23;	author leo;	state Exp;
branches;
next	1.10;

1.10
date	96.03.26.15.22.53;	author leo;	state Exp;
branches;
next	1.9;

1.9
date	96.03.25.11.21.38;	author msmeissn;	state Exp;
branches;
next	1.8;

1.8
date	96.03.22.22.20.59;	author msmeissn;	state Exp;
branches;
next	1.7;

1.7
date	96.03.22.12.14.26;	author msmeissn;	state Exp;
branches;
next	1.6;

1.6
date	96.03.22.11.58.26;	author msmeissn;	state Exp;
branches;
next	1.5;

1.5
date	96.03.21.13.54.34;	author msmeissn;	state Exp;
branches;
next	1.4;

1.4
date	96.03.21.12.42.59;	author msmeissn;	state Exp;
branches;
next	1.3;

1.3
date	96.03.19.20.49.20;	author msmeissn;	state Exp;
branches;
next	1.2;

1.2
date	96.03.18.20.39.08;	author leo;	state Exp;
branches;
next	1.1;

1.1
date	96.03.17.18.07.18;	author leo;	state Exp;
branches;
next	;

1.35.1.1
date	96.11.04.09.17.27;	author leo;	state Exp;
branches;
next	;


desc
@character display
@


1.36
log
@Changed repaint() so that it draws each characters alone.
This is rather slow!
@
text
@/**
 * CharDisplay -- a simple character display
 * --
 * $Id: CharDisplay.java,v 1.35 1996/09/05 11:55:40 leo Exp leo $
 * $timestamp: Tue Oct 15 12:01:11 1996 by Matthias L. Jugel :$
 *
 * This file is part of "The Java Telnet Applet".
 *
 * This is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * "The Java Telnet Applet" is distributed in the hope that it will be 
 * useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

package display;

import java.awt.Graphics;
import java.awt.Canvas;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;

/**
 * A simple character display.
 * @@version $Id: CharDisplay.java,v 1.35 1996/09/05 11:55:40 leo Exp leo $
 * @@author  Matthias L. Jugel, Marcus Meiﬂner
 */
public class CharDisplay extends Canvas
{
  /**
   * If you need the runtime version, just ask this variable.
   */
  public String version = "$Revision: 1.35 $ $Date: 1996/09/05 11:55:40 $";
  
  private Dimension size;			/* rows and columns */
  private char charArray[][];			/* contains the characters */
  private int charAttributes[][];		/* contains character attrs */
  private int bufSize, maxBufSize;		/* buffer sizes */

  private int windowBase;			/* where the start displaying */
  private int screenBase;			/* the actual screen start */
  private int topMargin;			/* top scroll margon */
  private int bottomMargin;			/* bottom scroll margon */

  private Font normalFont;			/* normal font */
  private int charWidth;			/* current width of a char */
  private int charHeight;			/* current height of a char */
  private int charDescent;			/* base line descent */
  private int resizeStrategy;			/* current resizing strategy */

  private int cursorX, cursorY;			/* current cursor position */

  private boolean screenLocked = false;		/* screen needs to be locked */
                                                /* because of paint requests */
                                                /* during other operations */
  private boolean update[];
  
  private Color color[] = { Color.black,
			    Color.red,
			    Color.green,
			    Color.yellow,
			    Color.blue,
			    Color.magenta,
			    Color.cyan,
			    Color.lightGray,
  };
  private final static int COLOR_FG_STD = 7;
  private final static int COLOR_BG_STD = 0;
  private final static int COLOR 	= 0x7f8;
  private final static int COLOR_FG     = 0x78;
  private final static int COLOR_BG     = 0x780;

  /**
   * Scroll up when inserting a line.
   */
  public final static boolean SCROLL_UP   = false;
  /**
   * Scroll down when inserting a line.
   */
  public final static boolean SCROLL_DOWN = true;

  /**
   * Do nothing when the container is resized.
   */
  public final static int RESIZE_NONE	= 0;
  /**
   * Resize the width and height of the characterscreen.
   */
  public final static int RESIZE_SCREEN	= 1;
  /**
   * Resize the font to the new screensize.
   */
  public final static int RESIZE_FONT	= 2;
  
  /**
   * Make character normal.
   */ 
  public final static int NORMAL	= 0x00;
  /**
   * Make character bold.
   */ 
  public final static int BOLD		= 0x01;
  /**
   * Underline character.
   */ 
  public final static int UNDERLINE	= 0x02;
  /**
   * Invert character.
   */ 
  public final static int INVERT	= 0x04;

  private void InitializeCharDisplay(int width, int height, 
                                     String fontname, int fsize)
  {
    normalFont = new Font(fontname, Font.PLAIN, fsize);
    setFont(normalFont);
    FontMetrics fm = getFontMetrics(normalFont);
    if(fm != null)
    {
      charWidth = fm.getMaxAdvance();
      charHeight = fm.getHeight();
      charDescent = fm.getDescent();
    }
    resizeStrategy = RESIZE_FONT;
    size = new Dimension(width, height);
    charArray = new char[size.height][size.width];
    charAttributes = new int[size.height][size.width];
    bufSize = size.height;
    maxBufSize = 2 * size.height;

    windowBase = 0;
    screenBase = 0;
    topMargin = 0;
    bottomMargin = size.height - 1;

    setForeground(color[COLOR_FG_STD]);
    setBackground(color[COLOR_BG_STD]);

    update = new boolean[size.height + 1];
    for(int i = 1; i <= size.height; i++) update[i] = true;
  }
  
  /**
   * Create a character display with size 80x24 and Font "Courier", size 12.
   */
  public CharDisplay()
  {
    InitializeCharDisplay(80, 24, "Courier", 12);
  }

  /**
   * Create a character display with specific size, Font is "Courier", size 12.
   */
  public CharDisplay(int width, int height)
  {
    InitializeCharDisplay(width, height, "Courier", 12);
  }

  /**
   * Create a character display with 80x24 and specific font and font size.
   */
  public CharDisplay(String fname, int fsize)
  {
    InitializeCharDisplay(80, 24, fname, fsize);
  }

  /**
   * Create a character display with specific size, font and font size.
   */
  public CharDisplay(int width, int height, String fname, int fsize)
  {
    InitializeCharDisplay(width, height, fname, fsize);
  }
  
  /**
   * Put a character on the screen with normal font and outline.
   * The character previously on that position will be overwritten.
   * You need to call redraw() to update the screen.
   * @@param c x-coordinate (column)
   * @@param l y-coordinate (line)
   * @@param ch the character to show on the screen
   * @@see #insertChar
   * @@see #deleteChar
   * @@see #redraw
   */
  public void putChar(int c, int l, char ch)
  {
    putChar(c, l, ch, NORMAL);
  }

  /**
   * Put a character on the screen with specific font and outline.
   * The character previously on that position will be overwritten.
   * You need to call redraw() to update the screen.
   * @@param c x-coordinate (column)
   * @@param l y-coordinate (line)
   * @@param ch the character to show on the screen
   * @@param attributes the character attributes
   * @@see #BOLD
   * @@see #UNDERLINE
   * @@see #INVERT
   * @@see #NORMAL
   * @@see #insertChar
   * @@see #deleteChar
   * @@see #redraw
   */  

  public void putChar(int c, int l, char ch, int attributes)
  {
    c = checkBounds(c, 0, size.width - 1);
    l = checkBounds(l, 0, size.height - 1);
    charArray[screenBase + l][c] = ch;
    charAttributes[screenBase + l][c] = attributes;
    markLine(l, 1);
  }

  /**
   * Get the character at the specified position.
   * @@param c x-coordinate (column)
   * @@param l y-coordinate (line)
   * @@see #putChar
   */
  public char getChar(int c, int l)
  {
    c = checkBounds(c, 0, size.width - 1);
    l = checkBounds(l, 0, size.height - 1);
    return charArray[l][c];
  }

  /**
   * Get the attributes for the specified position.
   * @@param c x-coordinate (column)
   * @@param l y-coordinate (line)
   * @@see #putChar
   */
  public int getAttributes(int c, int l)
  {
    c = checkBounds(c, 0, size.width - 1);
    l = checkBounds(l, 0, size.height - 1);
    return charAttributes[l][c];
  }

  /**
   * Insert a character at a specific position on the screen.
   * All character right to from this position will be moved one to the right.
   * You need to call redraw() to update the screen.
   * @@param c x-coordinate (column)
   * @@param l y-coordinate (line)
   * @@param ch the character to insert
   * @@param attributes the character attributes
   * @@see #BOLD
   * @@see #UNDERLINE
   * @@see #INVERT
   * @@see #NORMAL
   * @@see #putChar
   * @@see #deleteChar
   * @@see #redraw
   */
  public void insertChar(int c, int l, char ch, int attributes)
  {
    c = checkBounds(c, 0, size.width - 1);
    l = checkBounds(l, 0, size.height - 1);
    System.arraycopy(charArray[screenBase + l], c, 
		     charArray[screenBase + l], c + 1, size.width - c - 1);
    System.arraycopy(charAttributes[screenBase + l], c, 
		     charAttributes[screenBase + l], c + 1, size.width - c - 1);
    putChar(c, l, ch, attributes);
  }

  /**
   * Delete a character at a given position on the screen.
   * All characters right to the position will be moved one to the left.
   * You need to call redraw() to update the screen.
   * @@param c x-coordinate (column)
   * @@param l y-coordinate (line)
   * @@see #putChar
   * @@see #insertChar
   * @@see #redraw
   */
  public void deleteChar(int c, int l)
  {
    c = checkBounds(c, 0, size.width - 1);
    l = checkBounds(l, 0, size.height - 1);
    if(c < size.width - 1)
    {
      System.arraycopy(charArray[screenBase + l], c + 1,
		       charArray[screenBase + l], c, size.width - c - 1);
      System.arraycopy(charAttributes[screenBase + l], c + 1,
		       charAttributes[screenBase + l], c, size.width - c - 1);
    }
    putChar(size.width - 1, l, (char)0);
  }

  /**
   * Put a String at a specific position. Any characters previously on that 
   * position will be overwritten. You need to call redraw() for screen update.
   * @@param c x-coordinate (column)
   * @@param l y-coordinate (line)
   * @@param s the string to be shown on the screen
   * @@see #BOLD
   * @@see #UNDERLINE
   * @@see #INVERT
   * @@see #NORMAL
   * @@see #putChar
   * @@see #insertLine
   * @@see #deleteLine
   * @@see #redraw
   */  
  public void putString(int c, int l, String s)
  {
    putString(c, l, s, NORMAL);
  }
  
  /**
   * Put a String at a specific position giving all characters the same
   * attributes. Any characters previously on that position will be 
   * overwritten. You need to call redraw() to update the screen.
   * @@param c x-coordinate (column)
   * @@param l y-coordinate (line)
   * @@param s the string to be shown on the screen
   * @@param attributes character attributes
   * @@see #BOLD
   * @@see #UNDERLINE
   * @@see #INVERT
   * @@see #NORMAL
   * @@see #putChar
   * @@see #insertLine
   * @@see #deleteLine
   * @@see #redraw
   */
  public void putString(int c, int l, String s, int attributes)
  {
    for(int i = 0; i < s.length() && c + i < size.width; i++)
      putChar(c + i, l, s.charAt(i), attributes);
  }

  /**
   * Insert a blank line at a specific position.
   * The current line and all previous lines are scrolled one line up. The
   * top line is lost. You need to call redraw() to update the screen.
   * @@param l the y-coordinate to insert the line
   * @@see #deleteLine
   * @@see #redraw
   */
  public void insertLine(int l)
  {
    insertLine(l, 1, SCROLL_UP);
  }

  /**
   * Insert blank lines at a specific position.
   * You need to call redraw() to update the screen
   * @@param l the y-coordinate to insert the line
   * @@param n amount of lines to be inserted
   * @@see #deleteLine
   * @@see #redraw
   */
  public void insertLine(int l, int n)
  {
    insertLine(l, n, SCROLL_UP);
  }  

  /**
   * Insert a blank line at a specific position. Scroll text according to
   * the argument.
   * You need to call redraw() to update the screen
   * @@param l the y-coordinate to insert the line
   * @@param scrollDown scroll down
   * @@see #deleteLine
   * @@see #SCROLL_UP
   * @@see #SCROLL_DOWN
   * @@see #redraw
   */
  public void insertLine(int l, boolean scrollDown)
  {
    insertLine(l, 1, scrollDown);
  }  

  /**
   * Insert blank lines at a specific position.
   * The current line and all previous lines are scrolled one line up. The
   * top line is lost. You need to call redraw() to update the screen.
   * @@param l the y-coordinate to insert the line
   * @@param n number of lines to be inserted
   * @@param scrollDown scroll down
   * @@see #deleteLine
   * @@see #SCROLL_UP
   * @@see #SCROLL_DOWN
   * @@see #redraw
   */
  public synchronized void insertLine(int l, int n, boolean scrollDown)
  {
    screenLocked = true;

    l = checkBounds(l, 0, size.height - 1);

    char cbuf[][] = null;
    int abuf[][] = null;
    int offset = 0;
    int oldBase = screenBase;
    int top = (l < topMargin ? 
                0 : (l > bottomMargin ?
                      (bottomMargin + 1 < size.height ?
                        bottomMargin + 1 : size.height - 1) : topMargin));
    int bottom = (l > bottomMargin ?
                   size.height - 1 : (l < topMargin ? 
                                       (topMargin > 0 ?
                                        topMargin - 1 : 0) : bottomMargin));


    if(scrollDown)
    {
      if(n > (bottom - top)) n = (bottom - top);
      cbuf = new char[bottom - l - (n - 1)][size.width];
      abuf = new int[bottom - l - (n - 1)][size.width];
      
      System.arraycopy(charArray, oldBase + l, cbuf, 0, bottom - l - (n - 1));
      System.arraycopy(charAttributes, oldBase + l, abuf, 0, bottom - l - (n - 1));
      System.arraycopy(cbuf, 0, charArray, oldBase + l + n, bottom - l - (n - 1));
      System.arraycopy(abuf, 0, charAttributes, oldBase + l + n, bottom - l - (n - 1));
      cbuf = charArray;
      abuf = charAttributes;
    }
    else try
    {
      if(n > (bottom - top) + 1) n = (bottom - top) + 1;
      if(bufSize < maxBufSize)
      {
	if(bufSize + n > maxBufSize)
	{
	  offset = n - (maxBufSize - bufSize);
	  bufSize = maxBufSize;
	  screenBase = maxBufSize - size.height - 1;
	  windowBase = screenBase;
	}
	else
	{
	  screenBase += n;
	  windowBase += n;
	  bufSize += n;
	}
	cbuf = new char[bufSize][size.width];
	abuf = new int[bufSize][size.width];
      }
      else
      {
	offset = n;
	cbuf = charArray;
	abuf = charAttributes;
      }
      /*
       * copy anything from the top of the buffer (+offset) to the new top
       * up to the screenBase.
       */
      if(oldBase > 0)
      {
	System.arraycopy(charArray, offset, 
			 cbuf, 0, 
			 oldBase - offset);
	System.arraycopy(charAttributes, offset, 
			 abuf, 0, 
			 oldBase - offset);
      }
      /*
       * copy anything from the top of the screen (screenBase) up to the
       * topMargin to the new screen
       */
      if(top > 0)
      {
	System.arraycopy(charArray, oldBase, 
			 cbuf, screenBase, 
			 top);
	System.arraycopy(charAttributes, oldBase, 
			 abuf, screenBase, 
			 top);
      }
      /* 
       * copy anything from the topMargin up to the amount of lines inserted
       * to the gap left over between scrollback buffer and screenBase
       */
      System.arraycopy(charArray, oldBase + top, 
		       cbuf, oldBase - offset,
		       n);
      System.arraycopy(charAttributes, oldBase + top, 
		       abuf, oldBase - offset,
		       n);
      /*
       * copy anything from topMargin + n up to the line linserted to the
       * topMargin
       */
      System.arraycopy(charArray, oldBase + top + n,
		       cbuf, screenBase + top,
		       l - top - (n - 1));
      System.arraycopy(charAttributes, oldBase + top + n,
		       abuf, screenBase + top,
		       l - top - (n - 1));
      /*
       * copy the all lines next to the inserted to the new buffer
       */
      if(l < size.height - 1)
      {
	System.arraycopy(charArray, oldBase + l + 1,
			 cbuf, screenBase + l + 1,
			 (size.height - 1) - l);
	System.arraycopy(charAttributes, oldBase + l + 1,
			 abuf, screenBase + l + 1,
			 (size.height - 1) - l);
      }
    } catch(ArrayIndexOutOfBoundsException e) {
      System.err.println("*** Error while scrolling up:");
      System.err.println("--- BEGIN STACKTRACE ---");
      e.printStackTrace();
      System.err.println("--- END STACKTRACE ---");
      System.err.println("bufSize="+bufSize+", maxBufSize="+maxBufSize);
      System.err.println("top="+top+", bottom="+bottom);
      System.err.println("n="+n+", l="+l);
      System.err.println("screenBase="+screenBase+", windowBase="+windowBase);
      System.err.println("oldBase="+oldBase);
      System.err.println("size.width="+size.width+", size.height="+size.height);
      System.err.println("abuf.length="+abuf.length+", cbuf.length="+cbuf.length);
      System.err.println("*** done dumping debug information");
    }
    
    for(int i = 0; i < n; i++)
    {
      cbuf[(screenBase + l) + (scrollDown ? i : -i) ] = new char[size.width];
      abuf[(screenBase + l) + (scrollDown ? i : -i) ] = new int[size.width];
    }

    charArray = cbuf;
    charAttributes = abuf;

    if(scrollDown)
      markLine(l, bottom - l + 1);
    else
      markLine(top, l - top + 1);

    screenLocked = false;
  }

  /**
   * Delete a line at a specific position. Subsequent lines will be scrolled 
   * up to fill the space and a blank line is inserted at the end of the 
   * screen.
   * @@param l the y-coordinate to insert the line
   * @@see #deleteLine
   */
  public void deleteLine(int l)
  {
    l = checkBounds(l, 0, size.height - 1);

    int bottom = (l>bottomMargin?size.height-1:(l<topMargin?topMargin:bottomMargin));
    System.arraycopy(charArray, screenBase + l + 1,
		     charArray, screenBase + l, bottom - l);
    System.arraycopy(charAttributes, screenBase + l + 1,
		     charAttributes, screenBase + l, bottom - l);
    charArray[screenBase + size.height - 1] = new char[size.width];
    charAttributes[screenBase + size.height - 1] = new int[size.width];
    markLine(l, bottom - l);
  }


  /**
   * Delete a rectangular portion of the screen.
   * You need to call redraw() to update the screen.
   * @@param c x-coordinate (column)
   * @@param l y-coordinate (row)
   * @@param w with of the area in characters
   * @@param h height of the area in characters
   * @@see #deleteChar
   * @@see #deleteLine
   * @@see redraw
   */
  public void deleteArea(int c, int l, int w, int h)
  {
    c = checkBounds(c, 0, size.width - 1);
    l = checkBounds(l, 0, size.height - 1);

    char cbuf[] = new char[w];
    int abuf[] = new int[w];
    
    for(int i = 0; i < h && l + i < size.height; i++)
    {
      System.arraycopy(cbuf, 0, charArray[screenBase + l + i], c, w);
      System.arraycopy(abuf, 0, charAttributes[screenBase + l + i], c, w);
    }
    markLine(l, h);
  }

  /**
   * Puts the cursor at the specified position.
   * @@param c column
   * @@param l line
   */
  public void putCursor(int c, int l)
  {
    c = checkBounds(c, 0, size.width - 1);
    l = checkBounds(l, 0, size.height - 1);
    markLine(cursorY, 1);
    cursorX = (c < size.width ? c : size.width);
    cursorY = (l < size.height ? l : size.height);
    markLine(l, 1);
  }

  /**
   * Get the current cursor position.
   * @@see java.awt.Dimension
   */
  public Dimension getCursor()
  {
    return new Dimension(cursorX, cursorY);
  }

  /**
   * Set the top scroll margin for the screen. If the current bottom margin
   * is smaller it will become the top margin and the line will become the
   * bottom margin.
   * @@param l line that is the margin
   */
  public void setTopMargin(int l)
  {
    if(l > bottomMargin) 
    {
      topMargin = bottomMargin;
      bottomMargin = l;
    }
    else
      topMargin = l;
    if(topMargin < 0) topMargin = 0;
    if(bottomMargin > size.height - 1) bottomMargin = size.height - 1;
  }

  /**
   * Get the top scroll margin.
   */
  public int getTopMargin()
  {
    return topMargin;
  }

  /**
   * Set the bottom scroll margin for the screen. If the current top margin
   * is bigger it will become the bottom margin and the line will become the
   * top margin.
   * @@param l line that is the margin
   */
  public void setBottomMargin(int l)
  {
    if(l < topMargin) 
    {
      bottomMargin = topMargin;
      topMargin = l;
    }
    else
      bottomMargin = l;
    if(topMargin < 0) topMargin = 0;
    if(bottomMargin > size.height - 1) bottomMargin = size.height - 1;
  }

  /**
   * Get the bottom scroll margin.
   */
  public int getBottomMargin()
  {
    return bottomMargin;
  }
    
  /**
   * Set scrollback buffer size.
   * @@param amount new size of the buffer
   */
  public void setBufferSize(int amount)
  {
    screenLocked = true;

    if(amount < size.height) amount = size.height;
    if(amount < maxBufSize)
    {
      char cbuf[][] = new char[amount][size.width];
      int abuf[][] = new int[amount][size.width];
      System.arraycopy(charArray, bufSize - amount, cbuf, 0, amount);
      System.arraycopy(charAttributes, bufSize - amount, abuf, 0, amount);
      charArray = cbuf;
      charAttributes = abuf;
    }
    maxBufSize = amount;
 
    screenLocked = false;

    repaint();
  }

  /**
   * Retrieve current scrollback buffer size.
   * @@see #setBufferSize
   */
  public int getBufferSize()
  {
    return bufSize;
  }

  /**
   * Retrieve maximum buffer Size.
   * @@see #getBufferSize
   */
  public int getMaxBufferSize()
  {
    return maxBufSize;
  }

  /**
   * Set the current window base. This allows to view the scrollback buffer.
   * @@param line the line where the screen window starts
   * @@see setBufferSize
   * @@see getBufferSize
   */
  public void setWindowBase(int line)
  {
    if(line > screenBase) line = screenBase;
    else if(line < 0) line = 0;
    windowBase = line;
    repaint();
  }

  /**
   * Get the current window base.
   * @@see setWindowBase
   */
  public int getWindowBase()
  {
    return windowBase;
  }

  /**
   * Change the size of the screen. This will include adjustment of the 
   * scrollback buffer.
   * @@param columns width of the screen
   * @@param columns height of the screen
   */
  public void setWindowSize(int width, int height)
  {
    char cbuf[][];
    int abuf[][];
    int bsize = bufSize;

    if(width < 1 || height < 1) return;

    screenLocked = true;
    
    if(height > maxBufSize) 
      maxBufSize = height;
    if(height > bufSize)
    {
      bufSize = height;
      screenBase = 0;
      windowBase = 0;
    }

    cbuf = new char[bufSize][width];
    abuf = new int[bufSize][width];
    
    for(int i = 0; i < bsize && i < bufSize; i++)
    {
      System.arraycopy(charArray[i], 0, cbuf[i], 0, 
		       width < size.width ? width : size.width);
      System.arraycopy(charAttributes[i], 0, abuf[i], 0, 
		       width < size.width ? width : size.width);
    }
    charArray = cbuf;
    charAttributes = abuf;
    size = new Dimension(width, height);
    topMargin = 0;
    bottomMargin = height - 1;
    update = new boolean[height + 1];
    for(int i = 0; i <= height; i++) update[i] = true;
    screenLocked = false;
  }

  /**
   * Set the strategy when window is resized.
   * RESIZE_FONT is default.
   * @@param strategy the strategy
   * @@see #RESIZE_NONE
   * @@see #RESIZE_FONT
   * @@see #RESIZE_SCREEN
   */
  public void setResizeStrategy(int strategy)
  {
    resizeStrategy = strategy;
  }

  /**
   * Get amount of rows on the screen.
   */
  public int getRows() { return size.height; }

  /**
   * Get amount of columns on the screen.
   */
  public int getColumns() { return size.width; }

  /**
   * Mark lines to be updated with redraw().
   * @@param l starting line
   * @@param n amount of lines to be updated
   * @@see #redraw
   */
  public void markLine(int l, int n)
  {
    l = checkBounds(l, 0, size.height - 1);
    for(int i = 0; i < n && l + i < size.height; i++) 
      update[l + i + 1] = true;
  }
  
  /**
   * Redraw marked lines.
   * @@see #markLine
   */
  public void redraw()
  {
    update[0] = true;
    repaint();
  }

  /**
   * Update the display. to reduce flashing we have overriden this method.
   */
  public void update(Graphics g)
  {
    paint(g);
  }
  
  /**
   * Paint the current screen. All painting is done here. Only lines that have
   * changed will be redrawn!
   */
  public synchronized void paint(Graphics g)
  {
    if(screenLocked) return;

    int xoffset = (super.size().width - size.width * charWidth) / 2;
    int yoffset = (super.size().height - size.height * charHeight) / 2;

    Color fg = color[COLOR_FG_STD];
    Color bg = color[COLOR_BG_STD];

    g.setFont(normalFont);
    
    for(int l = 0; l < size.height; l++)
    {
      if(update[0] && !update[l + 1]) continue;
      update[l + 1] = false;
      for(int c = 0; c < size.width; c++)
      {
	int currAttr = 0;
	currAttr = charAttributes[windowBase + l][c];

	if ((currAttr & COLOR_FG) != 0) {
	  fg = color[((currAttr & COLOR_FG) >> 3)-1];
	}
	if ((currAttr & COLOR_BG) != 0) {
	  bg = color[((currAttr & COLOR_BG) >> 7)-1];
	}
	
	if((currAttr & BOLD) != 0)
	  fg = fg.brighter();

	if(charArray[windowBase + l][c] < ' ')
	  charArray[windowBase + l][c] = ' ';

	if((currAttr & INVERT) != 0) g.setColor(fg);
	else g.setColor(bg);

	g.fillRect(c * charWidth + xoffset, l * charHeight + yoffset,
		   charWidth, charHeight);
	g.setColor(fg);

	if((currAttr & INVERT) != 0) g.setColor(bg);

	g.drawChars(charArray[windowBase + l], c, 1, 
		    c * charWidth + xoffset, 
		    (l+1) * charHeight - charDescent + yoffset);

	if((currAttr & UNDERLINE) != 0)
	  g.drawLine(c * charWidth + 1 + xoffset,
		     (l+1) * charHeight - charDescent / 2 + yoffset,
		     c * charWidth + charWidth + xoffset, 
		     (l+1) * charHeight - charDescent / 2 + yoffset);

	if((currAttr & INVERT) != 0) g.setColor(fg);
      }
    }
    if(screenBase + cursorY >= windowBase && 
       screenBase + cursorY < windowBase + size.height)
    {
      g.setXORMode(getBackground());
      int widthDivider = 1;
      String system = System.getProperty("os.name");
      if(system.equals("Windows NT") || system.equals("BSD/OS"))
	widthDivider = 2;
      g.fillRect(cursorX * (charWidth / widthDivider) + xoffset, 
		 (cursorY + (screenBase - windowBase)) * charHeight + yoffset,
		 charWidth / widthDivider, charHeight);
      g.setPaintMode();
    }
    update[0] = false;
  }

  private int checkBounds(int value, int lower, int upper)
  {
    if(value < lower) return lower;
    if(value > upper) return upper;
    return value;
  }

  /**
   * Reshape character display according to resize strategy.
   * @@see #setResizeStrategy
   */
  public void reshape(int x, int y, int w, int h)
  {
    Font tmpFont = normalFont;
    FontMetrics fm = getFontMetrics(normalFont);
    if(fm != null)
    {
      charWidth = fm.charWidth('@@');
      charHeight = fm.getHeight();
    }
    switch(resizeStrategy)
    {
    case RESIZE_SCREEN:
      setWindowSize(w / charWidth, size.height = h / charHeight);
      break;
    case RESIZE_FONT:
      int height = h / size.height;
      int width = w / size.width;
      
      System.out.println("reshape(): width="+w+", height="+h);
      fm = getFontMetrics(normalFont = new Font(normalFont.getFamily(), 
				                Font.PLAIN, charHeight));

      // adapt current font size (from small up to best fit)
      if(fm.getHeight() < height || fm.getMaxAdvance() < width)
      {
	System.out.println("** Font too small ("+charHeight+"pt)"
			   +"["+width+":"+fm.getMaxAdvance()
			   +","+height+":"+fm.getHeight()+"], resizing...");
	do {
	  fm = getFontMetrics(normalFont = new Font(normalFont.getFamily(), 
						    Font.PLAIN, ++charHeight));
	  System.out.println("-- trying ("+charHeight+"pt)"
			   +"["+width+":"+fm.getMaxAdvance()
			   +","+height+":"+fm.getHeight()+"]");
	  
	} while(fm.getHeight() < height || fm.getMaxAdvance() < width); 
      }
      
      // now check if we got a font that is too large
      if(fm.getHeight() > height || fm.getMaxAdvance() > width)
      {
	System.out.println("** Font too large ("+charHeight+"pt)"
			   +"["+width+":"+fm.getMaxAdvance()
			   +","+height+":"+fm.getHeight()+"], resizing...");
	do {
	  fm = getFontMetrics(normalFont = new Font(normalFont.getFamily(),
	                                            Font.PLAIN, --charHeight));
	  System.out.println(fm);
	  System.out.println("-- trying ("+charHeight+"pt)"
			   +"["+width+":"+fm.getMaxAdvance()
			   +","+height+":"+fm.getHeight()+"]");
	} while(charHeight > 1 && 
		(fm.getHeight() > height || fm.getMaxAdvance() > width));
      }
      if(charHeight == 1) 
      {
	System.out.println("reshape(): oops, running Netscape on Solaris?");
	normalFont = tmpFont;
	System.out.println("reshape(): cannot determine font size, resetting");
	resizeStrategy = RESIZE_NONE;
	System.out.println("reshape(): disabling font/screen resize");
      }

      setFont(normalFont);
      fm = getFontMetrics(normalFont);
      charWidth = fm.getMaxAdvance();
      charHeight = fm.getHeight();
      charDescent = fm.getDescent();
      break;
    case RESIZE_NONE:
    default:
      break;
    }
    System.out.println("reshape(): font selected: "+normalFont);
    System.out.println("reshape(): fontmetrics: "+fm);
    super.reshape(x, y, w, h);
  }

  public Dimension preferredSize()
  {
    return size();
  }
  
  public Dimension minimumSize()
  {
    return size();
  }
  
  /**
   * Get the size of the character display in pixels.
   */
  public Dimension size()
  {
    // if(resizeStrategy != RESIZE_NONE) return super.size();
    
    FontMetrics fm = getFontMetrics(normalFont);
    if(fm != null)
    {
      charWidth = fm.getMaxAdvance();
      charHeight = fm.getHeight();
      charDescent = fm.getDescent();
    }
    System.out.println("size(): current fontmetrics: "+fm);
    System.out.println("size(): current window size: "
		       +(new Dimension(size.width * charWidth, 
				       size.height * charHeight)));
    return new Dimension(size.width * charWidth, size.height * charHeight);
  }

  public void addNotify()
  {
    super.addNotify();
  }
}
@


1.35
log
@fixed bug in font selection.
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.34 1996/08/29 16:02:23 leo Exp leo $
 * $timestamp: Wed Sep  4 08:54:59 1996 by Matthias L. Jugel :$
d36 1
a36 1
 * @@version $Id: CharDisplay.java,v 1.34 1996/08/29 16:02:23 leo Exp leo $
d44 1
a44 1
  public String version = "$Revision: 1.34 $ $Date: 1996/08/29 16:02:23 $";
d854 5
d866 1
a866 1
	int currAttr = 0, addr = 0;
a867 7
	while(c + addr < size.width && 
	      charAttributes[windowBase + l][c + addr] == currAttr)
	{
	  if(charArray[windowBase + l][c + addr] < ' ')
	    charArray[windowBase + l][c + addr] = ' ';
	  addr++;
	}
a868 3
	Color fg = color[COLOR_FG_STD];
	Color bg = color[COLOR_BG_STD];

d875 1
a875 2

	g.setFont(normalFont);
d879 2
a880 1
	g.setColor(fg);
d884 1
d886 1
a886 1
		   addr * charWidth, charHeight);
d891 1
a891 1
	g.drawChars(charArray[windowBase + l], c, addr, 
d898 1
a898 1
		     c * charWidth + addr * charWidth + xoffset, 
a901 2
	g.setFont(normalFont);
	c += addr - 1;
@


1.35.1.1
log
@widthDivider added to compensate font metrics errors
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.35 1996/09/05 11:55:40 leo Exp leo $
 * $timestamp: Mon Nov  4 10:15:44 1996 by Matthias L. Jugel :$
d36 1
a36 1
 * @@version $Id: CharDisplay.java,v 1.35 1996/09/05 11:55:40 leo Exp leo $
d44 1
a44 1
  public String version = "$Revision: 1.35 $ $Date: 1996/09/05 11:55:40 $";
a60 1
  private int widthDivider;			/* to compensate font errors */
a125 6
    String system = System.getProperty("os.name");
    String viewer = System.getProperty("java.vendor");
    System.out.println("CharDisplay: "+system+" ("+viewer+")");
    if(system.equals("Windows NT") || system.equals("BSD/OS"))
      widthDivider = 2;
    else widthDivider = 1;
d131 1
a131 1
      charWidth = fm.getMaxAdvance()/widthDivider;
d914 4
d960 1
a960 1
      if(fm.getHeight() < height || fm.getMaxAdvance()/widthDivider < width)
d963 1
a963 1
			   +"["+width+":"+fm.getMaxAdvance()/widthDivider
d969 1
a969 1
			   +"["+width+":"+fm.getMaxAdvance()/widthDivider
d972 1
a972 2
	} while(fm.getHeight() < height || 
		fm.getMaxAdvance()/widthDivider < width); 
d976 1
a976 1
      if(fm.getHeight() > height || fm.getMaxAdvance()/widthDivider > width)
d979 1
a979 1
			   +"["+width+":"+fm.getMaxAdvance()/widthDivider
d986 1
a986 1
			   +"["+width+":"+fm.getMaxAdvance()/widthDivider
d989 1
a989 2
		(fm.getHeight() > height || 
		 fm.getMaxAdvance()/widthDivider> width));
d1002 1
a1002 1
      charWidth = fm.getMaxAdvance()/widthDivider;
d1030 1
a1030 1
    if(resizeStrategy != RESIZE_NONE) return super.size();
d1035 1
a1035 1
      charWidth = fm.getMaxAdvance()/widthDivider;
@


1.34
log
@fixed @@version string
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.33 1996/08/29 15:28:32 leo Exp leo $
 * $timestamp: Thu Aug 29 16:25:39 1996 by Matthias L. Jugel :$
d36 1
a36 1
 * @@version $Id$
d44 1
a44 1
  public String version = "$Revision: 1.33 $ $Date: 1996/08/29 15:28:32 $";
d848 1
a848 1
  public void paint(Graphics g)
d939 1
d956 2
a957 2
      fm = getFontMetrics(new Font(normalFont.getFamily(), 
				   Font.PLAIN, charHeight));
d982 3
a984 2
	  fm = getFontMetrics(normalFont = new Font(normalFont.getFamily(), 
						    Font.PLAIN, --charHeight));
d988 2
a989 1
	} while(fm.getHeight() > height || fm.getMaxAdvance() > width);
d991 8
a1004 2
      System.out.println("reshape(): new font selected: "+normalFont);
      System.out.println("reshape(): fontmetrics: "+fm);
d1010 2
@


1.33
log
@synchronized insertLine()
@
text
@d4 1
a4 1
 * $Id: CharDisplay.java,v 1.32 1996/08/02 09:40:26 leo Exp leo $
d36 1
a36 1
 * @@version $Revision: 1.32 $ $Date: 1996/08/02 09:40:26 $
d44 1
a44 1
  public String version = "$Revision: 1.32 $ $Date: 1996/08/02 09:40:26 $";
@


1.32
log
@Added more debug info.
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.31 1996/07/30 10:30:51 leo Exp leo $
 * $timestamp: Fri Aug  2 11:38:19 1996 by Matthias L. Jugel :$
d36 1
a36 1
 * @@version $Revision: 1.31 $ $Date: 1996/07/30 10:30:51 $
d44 1
a44 1
  public String version = "$Revision: 1.31 $ $Date: 1996/07/30 10:30:51 $";
d402 1
a402 1
  public void insertLine(int l, int n, boolean scrollDown)
@


1.31
log
@minor font bug fix for Windows NT and BSD/OS
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.30 1996/07/19 12:30:22 leo Exp leo $
 * $timestamp: Tue Jul 30 12:01:34 1996 by  :$
d36 1
a36 1
 * @@version $Revision: 1.30 $ $Date: 1996/07/19 12:30:22 $
d44 1
a44 1
  public String version = "$Revision: 1.30 $ $Date: 1996/07/19 12:30:22 $";
d527 1
a527 1
      System.err.println("n="+n);
@


1.30
log
@fixed some typos in documentation.
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.29 1996/07/03 12:28:00 leo Exp leo $
 * $timestamp: Fri Jul 19 14:29:02 1996 by Matthias L. Jugel :$
d36 1
a36 1
 * @@version $Revision: 1.29 $ $Date: 1996/07/03 12:28:00 $
d44 1
a44 1
  public String version = "$Revision: 1.29 $ $Date: 1996/07/03 12:28:00 $";
d914 5
a918 1
      g.fillRect(cursorX * charWidth + xoffset, 
d920 1
a920 1
		 charWidth, charHeight);
d1033 5
@


1.29
log
@debugged font resizing (the only valid PC font is Courier 13pt)
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.28 1996/07/03 10:11:56 leo Exp leo $
 * $timestamp: Wed Jul  3 14:05:23 1996 by Matthias L. Jugel :$
d35 2
a36 3
 * A simple character display
 *
 * @@version $Revision: 1.28 $ $Date: 1996/07/03 10:11:56 $
d41 4
a44 1
  public String version = "$Revision: 1.28 $ $Date: 1996/07/03 10:11:56 $";
d189 1
d195 1
d205 1
a209 1
   * @@param repaint repaint the character array
d216 1
d257 1
d268 1
d284 1
d289 1
d307 1
a307 1
   * position will be overwritten.
a310 1
   * @@param attributes character attributes
d318 1
d328 1
a328 1
   * overwritten.
d340 1
d351 1
a351 1
   * top line is lost.
d354 1
d363 1
d367 1
d377 1
d379 1
a379 1
   * @@param scrollDown scroll backward?
d383 1
d393 1
a393 1
   * top line is lost.
d396 1
a396 1
   * @@param backScroll scroll backward?
d400 1
d408 2
a409 2
    char cbuf[][];
    int abuf[][];
d435 1
a435 1
    else
d520 13
d576 1
d583 1
@


1.28
log
@*** empty log message ***
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.27 1996/07/03 08:08:00 leo Exp leo $
 * $timestamp: Wed Jul  3 12:10:56 1996 by Matthias L. Jugel :$
d37 1
a37 1
 * @@version $Revision: 1.27 $ $Date: 1996/07/03 08:08:00 $
d42 1
a42 1
  public String version = "$Revision: 1.27 $ $Date: 1996/07/03 08:08:00 $";
d919 1
d925 4
d932 4
d937 2
d941 4
d948 3
d952 1
@


1.27
log
@fixed bug with color (std fore/background will be set on initialization)
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.26 1996/07/02 17:34:10 leo Exp leo $
 * $timestamp: Wed Jul  3 09:56:53 1996 by Matthias L. Jugel :$
d37 1
a37 1
 * @@version $Revision: 1.26 $ $Date: 1996/07/02 17:34:10 $
d42 1
a42 1
  public String version = "$Revision: 1.26 $ $Date: 1996/07/02 17:34:10 $";
d867 1
@


1.26
log
@some bugfixing, fontresizing
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.25 1996/06/21 06:09:40 leo Exp leo $
 * $timestamp: Tue Jul  2 19:09:18 1996 by Matthias L. Jugel :$
d37 1
a37 1
 * @@version $Revision: 1.25 $ $Date: 1996/06/21 06:09:40 $
d42 1
a42 1
  public String version = "$Revision: 1.25 $ $Date: 1996/06/21 06:09:40 $";
d145 3
d881 1
a881 1
      g.setXORMode(getForeground());
@


1.25
log
@*** empty log message ***
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.24 1996/06/10 16:02:52 leo Exp leo $
 * $timestamp: Wed Apr 24 15:04:09 1996 by Matthias L. Jugel :$
d37 1
a37 1
 * @@version $Revision: 1.24 $ $Date: 1996/06/10 16:02:52 $
d42 1
a42 1
  public String version = "$Revision: 1.24 $ $Date: 1996/06/10 16:02:52 $";
d133 1
a133 1
    resizeStrategy = RESIZE_NONE;
d917 8
d930 1
a930 5
      else
	do {
	  fm = getFontMetrics(normalFont = new Font(normalFont.getFamily(), 
						    Font.PLAIN, ++charHeight));
	} while(fm.getHeight() < height || fm.getMaxAdvance() < width); 
d936 2
a937 5
      System.out.println("FONT: "+normalFont);
      System.out.println("METRICS: "+fm);
      System.out.println("WIDTH: "+charWidth+" HEIGHT: "+charHeight);
      System.out.println("WIDTH: "+width+" HEIGHT: "+height);
      System.out.println("WIDTH: "+w+" HEIGHT: "+h);
a947 1
    System.out.println("preferredSize()");
a952 1
    System.out.println("minimumSize()");
d970 4
a973 2
    System.out.println(fm);
    System.out.println("size() = "+(new Dimension(size.width * charWidth, size.height * charHeight)));
@


1.24
log
@final revision.
@
text
@d4 1
a4 1
 * $Id: CharDisplay.java,v 1.23 1996/04/18 15:49:58 leo Exp leo $
d20 1
a20 1
 * along with GNU Emacs; see the file COPYING.  If not, write to the
d37 1
a37 1
 * @@version $Revision: 1.23 $ $Date: 1996/04/18 15:49:58 $
d42 1
a42 1
  public String version = "$Revision: 1.23 $ $Date: 1996/04/18 15:49:58 $";
@


1.23
log
@fixed bug on scrolldown
@
text
@d4 19
a22 2
 * $Id: CharDisplay.java,v 1.22 1996/04/03 14:19:36 leo Exp leo $
 * $timestamp: Thu Apr 18 17:42:20 1996 by Matthias L. Jugel :$
a26 1
import java.awt.Panel;
a28 1
import java.awt.Scrollbar;
d36 3
a38 2
 * @@version $Revision: 1.22 $ $Date: 1996/04/03 14:19:36 $
 * @@author Matthias L. Jugel
d42 1
a42 2
  public String version = "$Revision: 1.22 $ $Date: 1996/04/03 14:19:36 $";
  private Scrollbar sb = new Scrollbar(Scrollbar.VERTICAL);
d133 1
a133 1
    resizeStrategy = RESIZE_FONT;
d818 3
d855 1
a855 1
	g.fillRect(c * charWidth, l * charHeight,
d862 2
a863 1
		    c * charWidth, (l+1) * charHeight - charDescent);
d865 4
a868 3
	  g.drawLine(c * charWidth + 1, (l+1) * charHeight - charDescent / 2,
		     c * charWidth + addr * charWidth, 
		     (l+1) * charHeight - charDescent / 2);
d879 2
a880 2
      g.fillRect(cursorX * charWidth, 
		 (cursorY + (screenBase - windowBase)) * charHeight,
d945 12
d962 1
a962 1
    if(resizeStrategy != RESIZE_NONE) return super.size();
@


1.22
log
@Fixed bug in Fontresizing.
inverted display NOT by drawing in XOR mode, because windows doesn't
draw correctly.
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.21 1996/03/30 23:08:15 leo Exp leo $
 * $timestamp: Tue Apr  2 13:29:26 1996 by Matthias L. Jugel :$
d21 1
a21 1
 * @@version $Revision: 1.21 $ $Date: 1996/03/30 23:08:15 $
d26 1
a26 1
  public String version = "$Revision: 1.21 $ $Date: 1996/03/30 23:08:15 $";
d186 1
a186 1
   8 @@param attributes the character attributes
d390 1
a390 1
      if(n > (bottom - top) - l) n = (bottom - top) - l;
d846 1
a846 1
	  g.drawLine(c * charWidth + 1, (l+1) * charHeight - 2,
d897 1
a897 1
      if(fm.getHeight() > height || fm.charWidth('@@') > width)
d901 1
a901 1
	} while(fm.getHeight() > height || fm.charWidth('@@') > width);
d915 2
@


1.21
log
@*** empty log message ***
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.20 1996/03/30 23:05:25 leo Exp leo $
 * $timestamp: Sun Mar 31 00:07:55 1996 by leo :$
d21 1
a21 1
 * @@version $Revision: 1.20 $ $Date: 1996/03/30 23:05:25 $
d26 1
a26 1
  public String version = "$Revision: 1.20 $ $Date$";
a39 1
  private Font boldFont;			/* bold font */
d42 1
a109 1
    boldFont = new Font(fontname, Font.BOLD, fsize);
d114 1
a114 1
      charWidth = fm.charWidth('@@');
d116 1
a802 4
    FontMetrics fm = getFontMetrics(normalFont);
    charWidth = fm.charWidth('@@');
    charHeight = fm.getHeight();
    
d829 3
a831 8
	if(currAttr == 0 || ((currAttr & NORMAL) != 0)) 
	  g.setFont(normalFont);
	else 
	  if((currAttr & BOLD) != 0)
	  {
	    g.setFont(boldFont);
	    fg = fg.brighter();
	  }
d841 1
a841 1
	if((currAttr & INVERT) != 0) g.setXORMode(bg);
d843 2
a844 2
	g.drawChars(charArray[windowBase + l], c, addr, c * charWidth, 
		                                        (l+1) * charHeight - 4);
d847 2
a848 1
		     c * charWidth + addr * charWidth, (l+1) * charHeight - 2);
d850 1
a850 1
	if((currAttr & INVERT) != 0) g.setPaintMode();
d906 1
a906 2
	} while(fm.getHeight() < height || fm.charWidth('@@') < width); 
      boldFont = new Font(normalFont.getFamily(), Font.BOLD, charHeight);
d909 1
a909 1
      charWidth = fm.charWidth('@@');
d911 4
d933 1
a933 1
      charWidth = fm.charWidth('@@');
d935 1
@


1.20
log
@Version information.
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.19 1996/03/30 01:30:01 leo Exp leo $
 * $timestamp: Sun Mar 31 00:04:56 1996 by leo :$
d21 1
a21 1
 * @@version $Revision: 1.19 $ $Date: 1996/03/30 01:30:01 $
d26 1
a26 1
  protected String version = "$Revision$";
@


1.19
log
@Bugfix in underline.
Font resizing works.
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.18 1996/03/28 22:14:09 msmeissn Exp leo $
 * $timestamp: Sat Mar 30 01:27:10 1996 by leo :$
d21 1
a21 1
 * @@version $Revision: 1.18 $ $Date: 1996/03/28 22:14:09 $
d26 1
d63 3
a65 3
  private final static int COLOR 	= 0x1f8;
  private final static int COLOR_FG     = 0x38;
  private final static int COLOR_BG     = 0x1c0;
a105 33
  /**
   * Black
   */
  public final static int COLOR0	= 0x00;
  /**
   * Red 
   */
  public final static int COLOR1	= 0x08;
  /**
   * Green 
   */
  public final static int COLOR2	= 0x10;
  /**
   * Yellow 
   */
  public final static int COLOR3	= 0x18;
  /**
   * Blue 
   */
  public final static int COLOR4	= 0x20;
  /**
   * Magenta 
   */
  public final static int COLOR5	= 0x28;
  /**
   * Cyan 
   */
  public final static int COLOR6	= 0x30;
  /**
   * Lightgray 
   */
  public final static int COLOR7	= 0x38;
  
d186 1
a186 1
   * @@param attributes the character attributes
d826 5
a830 4
	if((currAttr & COLOR) != 0)
	{
	  fg = color[(currAttr & COLOR_FG) >> 3];
	  bg = color[(currAttr & COLOR_BG) >> 6];
d839 1
a839 1
	    fg.brighter();
d859 1
@


1.18
log
@*** empty log message ***
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.16 1996/03/28 19:25:37 leo Exp $
 * $timestamp: Thu Mar 28 20:23:16 1996 by Matthias L. Jugel :$
d21 1
a21 1
 * @@version $Revision: 1.16 $ $Date: 1996/03/28 19:25:37 $
d886 2
a887 2
	  g.drawLine(c * charWidth + 1, (l+1) * charHeight,
		     c * charWidth + addr * charWidth, (l+1) * charHeight);
a917 2
    System.out.println("reshape("+x+","+y+","+w+","+h+")");
    
d930 15
a944 2
      charHeight = h / size.height - 3;
      normalFont = new Font(normalFont.getFamily(), Font.PLAIN, charHeight);
d963 2
@


1.17
log
@artes.
@
text
@@


1.16
log
@*** empty log message ***
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.15 1996/03/27 16:25:27 leo Exp leo $
 * $timestamp: Wed Mar 27 20:49:00 1996 by leo :$
d21 1
a21 1
 * @@version $Revision: 1.15 $ $Date: 1996/03/27 16:25:27 $
d42 1
d76 13
d144 7
d745 2
a747 1
      maxBufSize = height;
a750 1
      update = new boolean[height];
d758 1
a758 1
      System.arraycopy(charArray, 0, cbuf, 0, 
d760 1
a760 1
      System.arraycopy(charAttributes, 0, abuf, 0, 
d766 4
d774 13
d877 1
a877 1
	g.fillRect(c * charWidth, l * charHeight + 4,
d884 1
a884 1
		                                        (l+1) * charHeight);
d897 2
a898 1
      g.fillRect(cursorX * charWidth, cursorY * charHeight + 4,
d911 51
@


1.15
log
@*** empty log message ***
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.15 1996/03/27 16:25:27 leo Exp $
 * $timestamp: Wed Mar 27 16:39:56 1996 by Matthias L. Jugel :$
d209 2
a210 1
    if(c < 0 || c > size.width - 1 || l < 0 || l > size.height - 1) return;
d224 2
a225 2
    if(c < 0 || c > size.width - 1 || l < 0 || l > size.height - 1)
      return (char)0;
d237 2
a238 2
    if(c < 0 || c > size.width - 1 || l < 0 || l > size.height - 1)
      return -1;
d258 2
a259 2
    if(c < 0 || c > size.width -1 || l < 0 || l > size.height - 1)
      return;
d277 2
a278 2
    if(c < 0 || c > size.width -1 || l < 0 || l > size.height - 1)
      return;
a326 2
    if(c < 0 || c > size.width - 1 || l < 0 || l > size.height - 1)
      return;
d383 1
a383 2
    if(l < 0 || l > size.height - 1)
      return;
d414 1
a414 1
      if(n > (bottom - top) - 1) n = (bottom - top) - 1;
d525 1
a525 2
    if(l < 0 || l > size.height - 1)
      return;
d549 3
d570 2
a571 2
    if(c < 0 || c > size.width - 1 || l < 0 || l > size.height - 1)
      return;
d766 1
a766 1
    if(l < 0) return;
d812 1
a812 1
	  if(charArray[windowBase + l][c + addr] == '\0')
d865 7
@


1.14
log
@Documentation cleaned up.
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.13 1996/03/27 11:02:03 leo Exp leo $
 * $timestamp: Wed Mar 27 12:17:14 1996 by Matthias L. Jugel :$
d21 1
a21 1
 * @@version $Revision: 1.13 $ $Date: 1996/03/27 11:02:03 $
a399 1
    if(n > (bottom - top) + 1) n = (bottom - top) + 1;
d403 1
d416 1
@


1.13
log
@Scrollareas do now work (backward scrolling and forward).
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.12 1996/03/26 16:46:38 leo Exp leo $
 * $timestamp: Wed Mar 27 12:00:36 1996 by Matthias L. Jugel :$
d21 1
a21 1
 * @@version $Revision$ $Date$
d65 3
d69 3
d90 2
a91 1
  /*
d95 3
d99 3
d103 3
d107 3
d111 3
d115 3
d119 3
d146 1
a146 1
   * Create a character display. Size is 80x24. Font is "Courier". Size 12.
d154 1
a154 1
   * Create a character display with specific. Font is "Courier". Size 12.
d170 1
a170 1
   * Create a character display with specific size, font and font size
d361 1
a362 1
   * @@see #SCROLL_UP
d377 2
a378 2
   * @@see #SCROLL_FORWARD
   * @@see #SCROLL_BACKWARD
d706 2
a707 1
  /* Change the size of the screen. This will include adjustment of the 
@


1.12
log
@fixed bug in deleteArea()
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.11 1996/03/26 16:00:23 leo Exp leo $
 * $timestamp: Tue Mar 26 17:46:08 1996 by Matthias L. Jugel :$
d21 1
a21 1
 * @@version $Id: CharDisplay.java,v 1.11 1996/03/26 16:00:23 leo Exp leo $
d43 7
d65 2
a66 1
  private int cursorX, cursorY;			/* current cursor position */
a67 5
  private boolean screenLocked = false;		/* screen needs to be locked */
                                                /* because of paint requests */
                                                /* during other operations */
  private boolean update[];
  
d111 1
a111 1
    bottomMargin = size.height;
d313 1
a313 1
    insertLine(l, 1);
d318 25
d347 1
d349 2
d352 1
a352 1
  public void insertLine(int l, int n)
d363 8
a370 2
    int top = (l<topMargin?0:(l>bottomMargin?bottomMargin:topMargin));
    int bottom = (l>bottomMargin?size.height-1:(l<topMargin?topMargin:bottomMargin));
d374 1
a374 1
    if(bufSize < maxBufSize)
d376 13
a388 1
      if(bufSize + n > maxBufSize)
d390 15
a404 4
	offset = n - (maxBufSize - bufSize);
	bufSize = maxBufSize;
	screenBase = maxBufSize - size.height - 1;
	windowBase = screenBase;
d408 61
a468 3
	screenBase += n;
	windowBase += n;
	bufSize += n;
a469 76
      cbuf = new char[bufSize][size.width];
      abuf = new int[bufSize][size.width];
    }
    else
    {
      offset = n;
      cbuf = charArray;
      abuf = charAttributes;
    }
    System.out.println("TOP="+top+" BOTTOM="+bottom+" n="+n+" offset="+offset);
    System.out.println("--\noldBase="+oldBase+" screenBase="+screenBase);
    /*
     * copy anything from the top of the buffer (+offset) to the new top
     * up to the screenBase.
     */
    if(oldBase > 0)
    {
//      System.out.println("Copying scrollback buffer:");
//      System.out.println("offset="+offset+" amount="+(oldBase - offset));
      System.arraycopy(charArray, offset, 
		       cbuf, 0, 
		       oldBase - offset);
      System.arraycopy(charAttributes, offset, 
		       abuf, 0, 
		       oldBase - offset);
    }
    /*
     * copy anything from the top of the screen (screenBase) up to the
     * topMargin to the new screen
     */
    if(top > 0)
    {
      System.out.println("Copying top of the screen buffer:");
      System.out.println("oldBase="+oldBase+" screenBase="+screenBase+" amount="+top);
      System.arraycopy(charArray, oldBase, 
		       cbuf, screenBase, 
		       top);
      System.arraycopy(charAttributes, oldBase, 
		       abuf, screenBase, 
		       top);
    }
    /* 
     * copy anything from the topMargin up to the amount of lines inserted
     * to the gap left over between scrollback buffer and screenBase
     */
    System.out.println("Copying from topMargin to scrollback buffer:");
    System.out.println("from="+(oldBase + top)+" to="+(oldBase - offset)+" amount="+n);
    System.arraycopy(charArray, oldBase + top, 
		     cbuf, oldBase - offset,
		     n);
    System.arraycopy(charAttributes, oldBase + top, 
		     abuf, oldBase - offset,
		     n);
    /*
     * copy anything from topMargin + n up to the line linserted to the
     * topMargin
     */
    System.out.println("Copying rest up to topMargin:");
    System.out.println("from="+(oldBase + top + n)+" to="+(screenBase + topMargin + n)+" amount="+(l - top - (n - 1)));
    System.arraycopy(charArray, oldBase + top + n,
		     cbuf, screenBase + top,
		     l - top - (n - 1));
    System.arraycopy(charAttributes, oldBase + top + n,
		     abuf, screenBase + top,
		     l - top - (n - 1));
    /*
     * copy the all lines next to the inserted to the new buffer
     */
    if(l < size.height - 1)
    {
      System.arraycopy(charArray, oldBase + l + 1,
		       cbuf, screenBase + l + 1,
		       (size.height - 1) - l);
      System.arraycopy(charAttributes, oldBase + l + 1,
		       abuf, screenBase + l + 1,
		       (size.height - 1) - l);
d474 2
a475 2
      cbuf[(screenBase + l) - i ] = new char[size.width];
      abuf[(screenBase + l) - i ] = new int[size.width];
d481 4
a484 1
    markLine(top, l - top);
d573 10
d600 10
d781 3
d785 1
d825 1
a825 1
    if(screenBase + cursorY > windowBase && 
@


1.11
log
@Some additions (deleteLine)
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.10 1996/03/26 15:22:53 leo Exp leo $
 * $timestamp: Tue Mar 26 16:59:37 1996 by Matthias L. Jugel :$
d21 1
a21 1
 * @@version $Id: CharDisplay.java,v 1.10 1996/03/26 15:22:53 leo Exp leo $
d362 1
a362 1
//    System.out.println("--\noldBase="+oldBase+" screenBase="+screenBase);
d384 2
a385 2
//      System.out.println("Copying top of the screen buffer:");
//      System.out.println("oldBase="+oldBase+" screenBase="+screenBase+" amount="+top);
d397 2
a398 2
//    System.out.println("Copying from topMargin to scrollback buffer:");
//    System.out.println("from="+(oldBase + top)+" to="+(oldBase - offset)+" amount="+n);
d409 2
a410 2
//    System.out.println("Copying rest up to topMargin:");
//    System.out.println("from="+(oldBase + top + n)+" to="+(screenBase + topMargin + n)+" amount="+(l - top - (n - 1)));
d481 1
a481 1
    for(int i = 0; i < h && l + i < size.height - 1; i++)
@


1.10
log
@Scroll areas added (VT topmarging/bottommargin)
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.9 1996/03/25 11:21:38 msmeissn Exp $
 * $timestamp: Tue Mar 26 16:20:26 1996 by Matthias L. Jugel :$
d21 1
a21 1
 * @@version $Id: CharDisplay.java,v 1.9 1996/03/25 11:21:38 msmeissn Exp $
d361 1
a361 1
//    System.out.println("TOP="+top+" BOTTOM="+bottom+" n="+n+" offset="+offset);
d455 2
d458 1
a458 1
		     charArray, screenBase + l, (size.height  - 1) - l);
d460 1
a460 1
		     charAttributes, screenBase + l, (size.height - 1) - l);
d463 1
a463 1
    markLine(l, size.height - l - 1);
@


1.9
log
@*** empty log message ***
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.8 1996/03/22 22:20:59 msmeissn Exp msmeissn $
 * $timestamp: Fri Mar 22 12:07:09 1996 by Matthias L. Jugel :$
a17 1
import java.awt.BorderLayout;
d21 1
a21 1
 * @@version $Id: CharDisplay.java,v 1.8 1996/03/22 22:20:59 msmeissn Exp msmeissn $
d32 2
d35 2
a36 1
  private int windowBase;			/* where the start displaying */
a37 1
  private Font font;				/* font to be used */
a39 1
  private int fontSize;				/* size of the font */
d96 1
a96 3
    fontSize = fsize;
    font = new Font(fontname, Font.PLAIN, fsize);
    normalFont = font;
d98 1
a98 1
    setFont(font);
d104 2
d107 3
a109 1
    windowBase = 0;
d331 3
a333 1
    int currPos = screenBase + l;
d335 1
a335 1
    if(n > size.height) n = size.height;
d361 59
a419 3
    
    System.arraycopy(charArray, offset, cbuf, 0, currPos - (offset - 1));
    System.arraycopy(charAttributes, offset, abuf, 0, currPos - (offset - 1));
d422 6
a427 4
      System.arraycopy(charArray, screenBase + l, 
		       cbuf, currPos + 1, (size.height - 1) - l);
      System.arraycopy(charAttributes, screenBase + l, 
		       abuf, currPos + 1, (size.height - 1) - l);
d429 1
d439 1
a439 1
    markLine(0, l);
d496 1
d512 34
d700 1
a700 1
    FontMetrics fm = getFontMetrics(font);
@


1.8
log
@*** empty log message ***
@
text
@d4 1
a4 1
 * $Id: CharDisplay.java,v 1.7 1996/03/22 12:14:26 msmeissn Exp msmeissn $
d22 1
a22 1
 * @@version $Id: CharDisplay.java,v 1.7 1996/03/22 12:14:26 msmeissn Exp msmeissn $
d421 1
a421 1
    markLine(l, h+1);
@


1.7
log
@hate wars
@
text
@d4 1
a4 1
 * $Id: CharDisplay.java,v 1.11 1996/03/21 23:48:01 leo Exp leo $
d22 1
a22 1
 * @@version $Id: CharDisplay.java,v 1.11 1996/03/21 23:48:01 leo Exp leo $
d418 2
a419 2
      System.arraycopy(cbuf, 0, charArray[l + i], c, w);
      System.arraycopy(abuf, 0, charArray[l + i], c, w);
d421 1
a421 1
    markLine(l, h);
@


1.6
log
@*** empty log message ***
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.10 1996/03/21 16:20:45 leo Exp $
 * $timestamp: Thu Mar 21 17:17:01 1996 by Matthias L. Jugel :$
d10 1
d13 1
d22 1
a22 1
 * @@version $Id: CharDisplay.java,v 1.10 1996/03/21 16:20:45 leo Exp $
d27 2
a107 1

d109 1
a109 2
    markLine(0, size.height);
    redraw();
d340 1
d345 1
d418 2
a419 2
      System.arraycopy(cbuf, 0, charArray, c, w);
      System.arraycopy(abuf, 0, charArray, c, w);
d473 18
d494 1
d500 2
d504 9
d533 1
d613 1
a613 1
	currAttr = charAttributes[screenBase + l][c];
d615 1
a615 1
	      charAttributes[screenBase + l][c + addr] == currAttr)
d646 1
a646 1
	g.drawChars(charArray[screenBase + l], c, addr, c * charWidth, 
d656 8
a663 4
    g.setXORMode(getForeground());
    g.fillRect(cursorX * charWidth, cursorY * charHeight + 4,
	       charWidth, charHeight);
    g.setPaintMode();
@


1.5
log
@*** empty log message ***
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.7 1996/03/21 13:50:51 leo Exp $
 * $timestamp: Thu Mar 21 14:45:37 1996 by Matthias L. Jugel :$
d20 1
a20 1
 * @@version $Id: CharDisplay.java,v 1.7 1996/03/21 13:50:51 leo Exp $
d106 2
d177 1
d372 2
d394 1
d397 1
d399 22
d431 1
a453 2
      System.out.println("TEST");
      
a527 1

d537 2
a538 1
    for(int i = 1; i <= n && l + i < size.height; i++) update[l + i] = true;
d577 1
a577 2
	int currAttr = 0, addr;
	addr = 0;
@


1.4
log
@*** empty log message ***
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.6 1996/03/21 11:24:07 leo Exp $
 * $timestamp: Thu Mar 21 12:22:52 1996 by Matthias L. Jugel :$
d20 1
a20 1
 * @@version $Id: CharDisplay.java,v 1.6 1996/03/21 11:24:07 leo Exp $
a142 1
   * Do not repaint.
a153 16
  /** 
   * Put a character on the screen with normal font and outline.
   * The character previously on that position will be overwritten.
   * Do repaint immediately.
   * @@param c x-coordinate (column)
   * @@param l y-coordinate (line)
   * @@param ch the character to show on the screen
   * @@param attributes the character attributes
   * @@see #insertChar
   * @@see #deleteChar
   */
  public void putChar(int c, int l, char ch, int attributes)
  {
    putChar(c, l, ch, attributes, true);
  }

d170 1
a170 1
  public void putChar(int c, int l, char ch, int attributes, boolean repaint)
a174 1
    if(repaint) redraw(l, 1);
d225 1
a225 1
    putChar(c, l, ch, attributes, true);
d291 1
a291 2
      putChar(c + i, l, s.charAt(i), attributes, false);
    redraw(l, 1);
a369 2

    redraw(0, l+1);
a388 1
    redraw(l, 1);
a401 1
    redraw(l, 1);
d500 1
d502 22
a599 7

  private void redraw(int l, int n)
  {
    for(int i = 1; i <= n; i++) update[l + i] = true;
    update[0] = true;
    repaint();
  }
@


1.3
log
@hates fixes
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.3 1996/03/19 20:46:38 leo Exp $
 * $timestamp: Tue Mar 19 21:30:38 1996 by leo :$
d20 1
a20 1
 * @@version $Id: CharDisplay.java,v 1.3 1996/03/19 20:46:38 leo Exp $
d39 15
d59 2
d64 1
a64 1
  public final static int NORMAL	= 0x01;
d68 1
a68 1
  public final static int BOLD		= 0x02;
d72 1
a72 1
  public final static int UNDERLINE	= 0x04;
d76 12
a87 1
  public final static int INVERT	= 0x08;
d94 2
d104 2
d189 1
a189 1
    if(c > size.width - 1 || l > size.height - 1) return;
d192 1
a192 1
    if(repaint) repaint();
d203 1
a203 1
    if(c > size.width -1 || l > size.height - 1 || c < 0 || l < 0)
d216 1
a216 1
    if(c > size.width -1 || l > size.height - 1 || c < 0 || l < 0)
d237 2
d256 2
d306 2
d310 1
a310 1
    repaint();
d322 13
d337 3
d343 1
d345 2
d349 11
a359 2
      bufSize++;
      screenBase++;
d365 1
a365 1
      offset = 1;
d369 3
a371 2
    System.arraycopy(charArray, offset, cbuf, 0, screenBase + l);
    System.arraycopy(charAttributes, offset, abuf, 0, screenBase + l);
d375 1
a375 1
		       cbuf, screenBase + l + 1, (size.height - 1) - l);
d377 1
a377 1
		       abuf, screenBase + l + 1, (size.height - 1) - l);
d379 1
a379 1
    else
d381 2
a382 2
      cbuf[screenBase + l] = new char[size.width];
      abuf[screenBase + l] = new int[size.width];
d384 1
d390 1
a390 1
    repaint();
d402 2
d410 1
a410 1
    repaint();
d420 2
d424 1
d427 4
d438 1
d447 2
d474 39
a541 3

    Color fg = g.getColor();
    Color bg = getBackground();
d545 2
d550 1
a551 1
	addr = 0;
d555 10
a564 1
	
a565 1
	{
a566 2
	  g.setPaintMode();
	}
d568 5
a572 4
	{
	  if((currAttr & BOLD) != 0) g.setFont(boldFont);
	  if((currAttr & INVERT) != 0) g.setXORMode(fg);
	}
d574 4
a577 1
	g.setColor(bg);
d579 2
a580 2
		   c * charWidth + charWidth * addr, charHeight);
	if((currAttr & INVERT) == 0) g.setColor(fg);
d582 2
d588 1
a588 1
		     c * charWidth + charWidth * addr, (l+1) * charHeight);
d590 1
a590 5
	if((currAttr & INVERT) != 0)
	{
	  g.setColor(fg);
	  g.setPaintMode();
	}
d594 1
a594 1
    g.setXORMode(bg);
d598 1
d600 7
@


1.2
log
@performance upgrade by marcus
@
text
@d4 2
a5 2
 * $Id: CharDisplay.java,v 1.1 1996/03/17 18:07:18 leo Exp leo $
 * $timestamp: Mon Mar 18 21:01:41 1996 by leo :$
d20 1
a20 1
 * @@version $Id: CharDisplay.java,v 1.1 1996/03/17 18:07:18 leo Exp leo $
d32 1
a32 1
  private String fontName;			/* font to be used */
d35 3
d39 2
d62 1
a62 1
                                     String font, int fsize)
d64 3
a66 1
    fontName = font;
d157 1
a157 1
    if(c > size.width - 1 || l > size.height -1) return;
d162 1
d164 26
d344 16
d420 4
a425 3
    FontMetrics fm = g.getFontMetrics();
    int charWidth = fm.charWidth('@@');
    int charHeight = fm.getHeight();
d468 4
a472 11

  /**
   * Reshape the screen and resize the font.
   */
  public void reshape(int x, int y, int w, int h)
  {
    normalFont = new Font(fontName, Font.PLAIN, h / size.height - 3);
    boldFont = new Font(fontName, Font.BOLD, h / size.height - 3);
    setFont(normalFont);
    super.reshape(x, y, w, h);
  }
@


1.1
log
@Initial revision
@
text
@d4 2
a5 2
 * $Id$
 * $timestamp: Sat Mar 16 18:03:58 1996 by Matthias L. Jugel :$
d20 1
a20 1
 * @@version $Id$
d56 2
a57 1
  private void InitializeCharDisplay(int width, int height, String font)
d70 1
a70 1
   * Create a character display. Size is 80x24. Font is "Courier".
d74 1
a74 1
    InitializeCharDisplay(80, 24, "Courier");
d78 1
a78 1
   * Create a character display with specific. Font is "Courier".
d82 1
a82 1
    InitializeCharDisplay(width, height, "Courier");
d86 1
a86 1
   * Create a character display with specific size and font.
d88 1
a88 1
  public CharDisplay(String fname)
d90 1
a90 1
    InitializeCharDisplay(80, 24, fname);
d94 1
a94 1
   * Create a character display. Size is 80x24. Font is "Courier".
d96 1
a96 1
  public CharDisplay(int width, int height, String fname)
d98 1
a98 1
    InitializeCharDisplay(width, height, fname);
d104 1
d116 16
d139 1
d147 2
a148 1
  public void putChar(int c, int l, char ch, int attributes)
d153 1
a153 1
    repaint();
a154 1

d175 1
a175 1
    putChar(c, l, ch, attributes);
d237 2
a238 1
      putChar(c + i, l, s.charAt(i), attributes);
@
